/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!../../node_modules/@melloware/coloris/dist/coloris.css":
/*!****************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!../../node_modules/@melloware/coloris/dist/coloris.css ***!
  \****************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../docs/example/node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../docs/example/node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".clr-picker {\\r\\n  display: none;\\r\\n  flex-wrap: wrap;\\r\\n  position: absolute;\\r\\n  width: 200px;\\r\\n  z-index: 1000;\\r\\n  border-radius: 10px;\\r\\n  background-color: #fff;\\r\\n  justify-content: space-between;\\r\\n  box-shadow: 0 0 5px rgba(0,0,0,.05), 0 5px 20px rgba(0,0,0,.1);\\r\\n  -moz-user-select: none;\\r\\n  -webkit-user-select: none;\\r\\n  user-select: none;\\r\\n}\\r\\n\\r\\n.clr-picker.clr-open,\\r\\n.clr-picker[data-inline=\\\"true\\\"] {\\r\\n  display: flex;\\r\\n}\\r\\n\\r\\n.clr-picker[data-inline=\\\"true\\\"] {\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n.clr-gradient {\\r\\n  position: relative;\\r\\n  width: 100%;\\r\\n  height: 100px;\\r\\n  margin-bottom: 15px;\\r\\n  border-radius: 3px 3px 0 0;\\r\\n  background-image: linear-gradient(rgba(0,0,0,0), #000), linear-gradient(90deg, #fff, currentColor);\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-marker {\\r\\n  position: absolute;\\r\\n  width: 12px;\\r\\n  height: 12px;\\r\\n  margin: -6px 0 0 -6px;\\r\\n  border: 1px solid #fff;\\r\\n  border-radius: 50%;\\r\\n  background-color: currentColor;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-picker input[type=\\\"range\\\"]::-webkit-slider-runnable-track {\\r\\n  width: 100%;\\r\\n  height: 8px;\\r\\n}\\r\\n\\r\\n.clr-picker input[type=\\\"range\\\"]::-webkit-slider-thumb {\\r\\n  width: 8px;\\r\\n  height: 8px;\\r\\n  -webkit-appearance: none;\\r\\n}\\r\\n\\r\\n.clr-picker input[type=\\\"range\\\"]::-moz-range-track {\\r\\n  width: 100%;\\r\\n  height: 8px;\\r\\n  border: 0;\\r\\n}\\r\\n\\r\\n.clr-picker input[type=\\\"range\\\"]::-moz-range-thumb {\\r\\n  width: 8px;\\r\\n  height: 8px;\\r\\n  border: 0;\\r\\n}\\r\\n\\r\\n.clr-hue {\\r\\n  background-image: linear-gradient(to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%);\\r\\n}\\r\\n\\r\\n.clr-hue,\\r\\n.clr-alpha {\\r\\n  position: relative;\\r\\n  width: calc(100% - 40px);\\r\\n  height: 8px;\\r\\n  margin: 5px 20px;\\r\\n  border-radius: 4px;\\r\\n}\\r\\n\\r\\n.clr-alpha span {\\r\\n  display: block;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n  border-radius: inherit;\\r\\n  background-image: linear-gradient(90deg, rgba(0,0,0,0), currentColor);\\r\\n}\\r\\n\\r\\n.clr-hue input,\\r\\n.clr-alpha input {\\r\\n  position: absolute;\\r\\n  width: calc(100% + 16px);\\r\\n  height: 16px;\\r\\n  left: -8px;\\r\\n  top: -4px;\\r\\n  margin: 0;\\r\\n  background-color: transparent;\\r\\n  opacity: 0;\\r\\n  cursor: pointer;\\r\\n  appearance: none;\\r\\n  -webkit-appearance: none;\\r\\n}\\r\\n\\r\\n.clr-hue div,\\r\\n.clr-alpha div {\\r\\n  position: absolute;\\r\\n  width: 16px;\\r\\n  height: 16px;\\r\\n  left: 0;\\r\\n  top: 50%;\\r\\n  margin-left: -8px;\\r\\n  transform: translateY(-50%);\\r\\n  border: 2px solid #fff;\\r\\n  border-radius: 50%;\\r\\n  background-color: currentColor;\\r\\n  box-shadow: 0 0 1px #888;\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.clr-alpha div:before {\\r\\n  content: '';\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  border-radius: 50%;\\r\\n  background-color: currentColor;\\r\\n}\\r\\n\\r\\n.clr-format {\\r\\n  display: none;\\r\\n  order: 1;\\r\\n  width: calc(100% - 40px);\\r\\n  margin: 0 20px 20px;\\r\\n}\\r\\n\\r\\n.clr-segmented {\\r\\n  display: flex;\\r\\n  position: relative;\\r\\n  width: 100%;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n  border: 1px solid #ddd;\\r\\n  border-radius: 15px;\\r\\n  box-sizing: border-box;\\r\\n  color: #999;\\r\\n  font-size: 12px;\\r\\n}\\r\\n\\r\\n.clr-segmented input,\\r\\n.clr-segmented legend {\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n  border: 0;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  opacity: 0;\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.clr-segmented label {\\r\\n  flex-grow: 1;\\r\\n  padding: 4px 0;\\r\\n  text-align: center;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-segmented label:first-of-type {\\r\\n  border-radius: 10px 0 0 10px;\\r\\n}\\r\\n\\r\\n.clr-segmented label:last-of-type {\\r\\n  border-radius: 0 10px 10px 0;\\r\\n}\\r\\n\\r\\n.clr-segmented input:checked + label {\\r\\n  color: #fff;\\r\\n  background-color: #666;\\r\\n}\\r\\n\\r\\n.clr-swatches {\\r\\n  order: 2;\\r\\n  width: calc(100% - 32px);\\r\\n  margin: 0 16px;\\r\\n}\\r\\n\\r\\n.clr-swatches div {\\r\\n  display: flex;\\r\\n  flex-wrap: wrap;\\r\\n  padding-bottom: 12px;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.clr-swatches button {\\r\\n  position: relative;\\r\\n  width: 20px;\\r\\n  height: 20px;\\r\\n  margin: 0 4px 6px 4px;\\r\\n  border: 0;\\r\\n  border-radius: 50%;\\r\\n  color: inherit;\\r\\n  text-indent: -1000px;\\r\\n  white-space: nowrap;\\r\\n  overflow: hidden;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-swatches button:after {\\r\\n  content: '';\\r\\n  display: block;\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  border-radius: inherit;\\r\\n  background-color: currentColor;\\r\\n  box-shadow: inset 0 0 0 1px rgba(0,0,0,.1);\\r\\n}\\r\\n\\r\\ninput.clr-color {\\r\\n  order: 1;\\r\\n  width: calc(100% - 80px);\\r\\n  height: 32px;\\r\\n  margin: 15px 20px 20px 0;\\r\\n  padding: 0 10px;\\r\\n  border: 1px solid #ddd;\\r\\n  border-radius: 16px;\\r\\n  color: #444;\\r\\n  background-color: #fff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 14px;\\r\\n  text-align: center;\\r\\n  box-shadow: none;\\r\\n}\\r\\n\\r\\ninput.clr-color:focus {\\r\\n  outline: none;\\r\\n  border: 1px solid #1e90ff;\\r\\n}\\r\\n\\r\\n.clr-clear {\\r\\n  display: none;\\r\\n  order: 2;\\r\\n  height: 24px;\\r\\n  margin: 0 20px 20px auto;\\r\\n  padding: 0 20px;\\r\\n  border: 0;\\r\\n  border-radius: 12px;\\r\\n  color: #fff;\\r\\n  background-color: #666;\\r\\n  font-family: inherit;\\r\\n  font-size: 12px;\\r\\n  font-weight: 400;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-preview {\\r\\n  position: relative;\\r\\n  width: 32px;\\r\\n  height: 32px;\\r\\n  margin: 15px 0 20px 20px;\\r\\n  border: 0;\\r\\n  border-radius: 50%;\\r\\n  overflow: hidden;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-preview:before,\\r\\n.clr-preview:after {\\r\\n  content: '';\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  border: 1px solid #fff;\\r\\n  border-radius: 50%;\\r\\n}\\r\\n\\r\\n.clr-preview:after {\\r\\n  border: 0;\\r\\n  background-color: currentColor;\\r\\n  box-shadow: inset 0 0 0 1px rgba(0,0,0,.1);\\r\\n}\\r\\n\\r\\n.clr-marker,\\r\\n.clr-hue div,\\r\\n.clr-alpha div,\\r\\n.clr-color {\\r\\n  box-sizing: border-box;\\r\\n}\\r\\n\\r\\n.clr-field {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  color: transparent;\\r\\n}\\r\\n\\r\\n.clr-field button {\\r\\n  position: absolute;\\r\\n  width: 30px;\\r\\n  height: 100%;\\r\\n  right: 0;\\r\\n  top: 50%;\\r\\n  transform: translateY(-50%);\\r\\n  border: 0;\\r\\n  color: inherit;\\r\\n  text-indent: -1000px;\\r\\n  white-space: nowrap;\\r\\n  overflow: hidden;\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.clr-field button:after {\\r\\n  content: '';\\r\\n  display: block;\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  border-radius: inherit;\\r\\n  background-color: currentColor;\\r\\n  box-shadow: inset 0 0 1px rgba(0,0,0,.5);\\r\\n}\\r\\n\\r\\n.clr-alpha,\\r\\n.clr-alpha div,\\r\\n.clr-swatches button,\\r\\n.clr-preview:before,\\r\\n.clr-field button {\\r\\n  background-image: repeating-linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%, #aaa), repeating-linear-gradient(45deg, #aaa 25%, #fff 25%, #fff 75%, #aaa 75%, #aaa);\\r\\n  background-position: 0 0, 4px 4px;\\r\\n  background-size: 8px 8px;\\r\\n}\\r\\n\\r\\n.clr-marker:focus {\\r\\n  outline: none;\\r\\n}\\r\\n\\r\\n.clr-keyboard-nav .clr-marker:focus,\\r\\n.clr-keyboard-nav .clr-hue input:focus + div,\\r\\n.clr-keyboard-nav .clr-alpha input:focus + div,\\r\\n.clr-keyboard-nav .clr-segmented input:focus + label {\\r\\n  outline: none;\\r\\n  box-shadow: 0 0 0 2px #1e90ff, 0 0 2px 2px #fff;\\r\\n}\\r\\n\\r\\n.clr-picker[data-alpha=\\\"false\\\"] .clr-alpha {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n.clr-picker[data-minimal=\\\"true\\\"] {\\r\\n  padding-top: 16px;\\r\\n}\\r\\n\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-gradient,\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-hue,\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-alpha,\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-color,\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-preview {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n/** Dark theme **/\\r\\n\\r\\n.clr-dark {\\r\\n  background-color: #444;\\r\\n}\\r\\n\\r\\n.clr-dark .clr-segmented {\\r\\n  border-color: #777;\\r\\n}\\r\\n\\r\\n.clr-dark .clr-swatches button:after {\\r\\n  box-shadow: inset 0 0 0 1px rgba(255,255,255,.3);\\r\\n}\\r\\n\\r\\n.clr-dark input.clr-color {\\r\\n  color: #fff;\\r\\n  border-color: #777;\\r\\n  background-color: #555;\\r\\n}\\r\\n\\r\\n.clr-dark input.clr-color:focus {\\r\\n  border-color: #1e90ff;\\r\\n}\\r\\n\\r\\n.clr-dark .clr-preview:after {\\r\\n  box-shadow: inset 0 0 0 1px rgba(255,255,255,.5);\\r\\n}\\r\\n\\r\\n.clr-dark .clr-alpha,\\r\\n.clr-dark .clr-alpha div,\\r\\n.clr-dark .clr-swatches button,\\r\\n.clr-dark .clr-preview:before {\\r\\n  background-image: repeating-linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #888 75%, #888), repeating-linear-gradient(45deg, #888 25%, #444 25%, #444 75%, #888 75%, #888);\\r\\n}\\r\\n\\r\\n/** Polaroid theme **/\\r\\n\\r\\n.clr-picker.clr-polaroid {\\r\\n  border-radius: 6px;\\r\\n  box-shadow: 0 0 5px rgba(0,0,0,.1), 0 5px 30px rgba(0,0,0,.2);\\r\\n}\\r\\n\\r\\n.clr-picker.clr-polaroid:before {\\r\\n  content: '';\\r\\n  display: block;\\r\\n  position: absolute;\\r\\n  width: 16px;\\r\\n  height: 10px;\\r\\n  left: 20px;\\r\\n  top: -10px;\\r\\n  border: solid transparent;\\r\\n  border-width: 0 8px 10px 8px;\\r\\n  border-bottom-color: currentColor;\\r\\n  box-sizing: border-box;\\r\\n  color: #fff;\\r\\n  filter: drop-shadow(0 -4px 3px rgba(0,0,0,.1));\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.clr-picker.clr-polaroid.clr-dark:before {\\r\\n  color: #444;\\r\\n}\\r\\n\\r\\n.clr-picker.clr-polaroid.clr-left:before {\\r\\n  left: auto;\\r\\n  right: 20px;\\r\\n}\\r\\n\\r\\n.clr-picker.clr-polaroid.clr-top:before {\\r\\n  top: auto;\\r\\n  bottom: -10px;\\r\\n  transform: rotateZ(180deg);\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-gradient {\\r\\n  width: calc(100% - 20px);\\r\\n  height: 120px;\\r\\n  margin: 10px;\\r\\n  border-radius: 3px;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-hue,\\r\\n.clr-polaroid .clr-alpha {\\r\\n  width: calc(100% - 30px);\\r\\n  height: 10px;\\r\\n  margin: 6px 15px;\\r\\n  border-radius: 5px;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-hue div,\\r\\n.clr-polaroid .clr-alpha div {\\r\\n  box-shadow: 0 0 5px rgba(0,0,0,.2);\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-format {\\r\\n  width: calc(100% - 20px);\\r\\n  margin: 0 10px 15px;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-swatches {\\r\\n  width: calc(100% - 12px);\\r\\n  margin: 0 6px;\\r\\n}\\r\\n.clr-polaroid .clr-swatches div {\\r\\n  padding-bottom: 10px;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-swatches button {\\r\\n  width: 22px;\\r\\n  height: 22px;\\r\\n}\\r\\n\\r\\n.clr-polaroid input.clr-color {\\r\\n  width: calc(100% - 60px);\\r\\n  margin: 10px 10px 15px 0;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-clear {\\r\\n  margin: 0 10px 15px auto;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-preview {\\r\\n  margin: 10px 0 15px 10px;\\r\\n}\\r\\n\\r\\n/** Large theme **/\\r\\n\\r\\n.clr-picker.clr-large {\\r\\n  width: 275px;\\r\\n}\\r\\n\\r\\n.clr-large .clr-gradient {\\r\\n  height: 150px;\\r\\n}\\r\\n\\r\\n.clr-large .clr-swatches button {\\r\\n  width: 22px;\\r\\n  height: 22px;\\r\\n}\\r\\n\\r\\n/** Pill (horizontal) theme **/\\r\\n\\r\\n.clr-picker.clr-pill {\\r\\n  width: 380px;\\r\\n  padding-left: 180px;\\r\\n  box-sizing: border-box;\\r\\n}\\r\\n\\r\\n.clr-pill .clr-gradient {\\r\\n  position: absolute;\\r\\n  width: 180px;\\r\\n  height: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  margin-bottom: 0;\\r\\n  border-radius: 3px 0 0 3px;\\r\\n}\\r\\n\\r\\n.clr-pill .clr-hue {\\r\\n  margin-top: 20px;\\r\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://jsdraw/../../node_modules/@melloware/coloris/dist/coloris.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!../../src/Editor.css":
/*!******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!../../src/Editor.css ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../docs/example/node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../docs/example/node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_cjs_js_toolbar_toolbar_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../docs/example/node_modules/css-loader/dist/cjs.js!./toolbar/toolbar.css */ \"./node_modules/css-loader/dist/cjs.js!../../src/toolbar/toolbar.css\");\n// Imports\n\n\n\nvar ___CSS_LOADER_EXPORT___ = _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n___CSS_LOADER_EXPORT___.i(_docs_example_node_modules_css_loader_dist_cjs_js_toolbar_toolbar_css__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n.imageEditorContainer {\\n\\t/* Deafult colors for the editor */\\n    --primary-background-color: white;\\n    --primary-background-color-transparent: rgba(255, 255, 255, 0.5);\\n    --secondary-background-color: #faf;\\n    --primary-foreground-color: black;\\n    --secondary-foreground-color: black;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n\\t.imageEditorContainer {\\n\\t\\t--primary-background-color: #151515;\\n\\t\\t--primary-background-color-transparent: rgba(50, 50, 50, 0.5);\\n\\t\\t--secondary-background-color: #607;\\n\\t\\t--primary-foreground-color: white;\\n\\t\\t--secondary-foreground-color: white;\\n\\t}\\n}\\n\\n.imageEditorContainer {\\n\\tcolor: var(--primary-foreground-color);\\n\\tfont-family: system-ui, -apple-system, sans-serif;\\n\\tbackground-color: var(--primary-background-color);\\n\\n\\tdisplay: flex;\\n\\tflex-direction: column-reverse;\\n}\\n\\n.imageEditorContainer .imageEditorRenderArea {\\n\\tdisplay: grid;\\n\\tgrid-template-columns: 1fr;\\n\\tflex-grow: 2;\\n\\tflex-shrink: 1;\\n\\tmin-height: 100px;\\n}\\n\\n.imageEditorContainer .imageEditorRenderArea canvas {\\n\\t/* Stack all canvases on top of each other */\\n\\tgrid-row: 1 / 1;\\n\\tgrid-column: 1 / 1;\\n\\ttouch-action: none;\\n\\n\\t/* Fill the container */\\n\\tbox-sizing: border-box;\\n\\twidth: 100%;\\n\\theight: 100%;\\n}\\n\\n.imageEditorContainer .loadingMessage {\\n\\tposition: fixed;\\n\\ttext-align: center;\\n\\tfont-size: 2em;\\n\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n}\\n\\n.imageEditorContainer .accessibilityAnnouncement {\\n\\topacity: 0;\\n\\twidth: 0;\\n\\theight: 0;\\n\\toverflow: hidden;\\n\\tpointer-events: none;\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://jsdraw/../../src/Editor.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!../../src/toolbar/toolbar.css":
/*!***************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!../../src/toolbar/toolbar.css ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../docs/example/node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../docs/example/node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _docs_example_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_docs_example_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".toolbar-root {\\n    background-color: var(--primary-background-color);\\n\\n    border: 1px solid var(--secondary-background-color);\\n    border-radius: 2px;\\n    flex-wrap: wrap;\\n\\n    box-sizing: border-box;\\n    width: 100%;\\n\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: center;\\n\\n    font-family: system-ui, -apple-system, sans-serif;\\n}\\n\\n.toolbar-button, .toolbar-root button {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n\\n    text-align: center;\\n    border-radius: 6px;\\n    cursor: pointer;\\n\\n    padding-left: 3px;\\n    padding-right: 3px;\\n    margin-left: 3px;\\n    margin-right: 3px;\\n\\n    min-width: 40px;\\n    max-width: 70px;\\n    font-size: 11pt;\\n\\n    cursor: pointer;\\n\\n    height: min(20vh, 60px);\\n    background-color: var(--primary-background-color);\\n    color: var(--primary-foreground-color);\\n    border: none;\\n    box-shadow: 0px 0px 2px var(--primary-foreground-color);\\n\\n    transition: background-color 0.25s ease, box-shadow 0.25s ease, opacity 0.3s ease;\\n}\\n\\n.toolbar-button:hover, .toolbar-root button:not(:disabled):hover {\\n    box-shadow: 0px 2px 4px var(--primary-foreground-color);\\n}\\n\\n.toolbar-root button {\\n    height: auto;\\n}\\n\\n.toolbar-root button:disabled {\\n    cursor: inherit;\\n    filter: opacity(0.5);\\n}\\n\\n.toolbar-button .toolbar-icon {\\n    flex-shrink: 1;\\n    min-width: 30px;\\n}\\n\\n.toolbar-toolContainer.selected .toolbar-button {\\n    background-color: var(--secondary-background-color);\\n    color: var(--secondary-foreground-color);\\n}\\n\\n.toolbar-toolContainer:not(.selected) .toolbar-showHideDropdownIcon {\\n    display: none;\\n}\\n\\n.toolbar-toolContainer.selected .toolbar-showHideDropdownIcon {\\n    height: 10px;\\n    transition: transform 0.5s ease;\\n}\\n\\n.toolbar-toolContainer.dropdownVisible .toolbar-showHideDropdownIcon {\\n    transform: rotate(180deg);\\n}\\n\\n.toolbar-dropdown.hidden, .toolbar-toolContainer:not(.selected) > .toolbar-dropdown {\\n    display: none;\\n}\\n\\n.toolbar-dropdown {\\n    position: absolute;\\n    padding: 15px;\\n    padding-top: 5px;\\n    /* Prevent overlap/being displayed under the undo/redo buttons */\\n    z-index: 2;\\n    background-color: var(--primary-background-color);\\n    box-shadow: 0px 3px 3px var(--primary-foreground-color);\\n}\\n\\n.toolbar-buttonGroup {\\n    display: flex;\\n    flex-direction: row;\\n}\\n\\n.toolbar-closeColorPickerOverlay {\\n    display: none;\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    bottom: 0;\\n    right: 0;\\n\\n    background-color: var(--primary-background-color);\\n    opacity: 0.3;\\n}\\n\\n/* Make color selection buttons fill their containing label */\\n.toolbar-dropdown .clr-field button {\\n    width: 100%;\\n    height: 100%;\\n    border-radius: 2px;\\n    margin-left: 0;\\n    margin-right: 0;\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://jsdraw/../../src/toolbar/toolbar.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://jsdraw/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://jsdraw/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "../../node_modules/@melloware/coloris/dist/coloris.css":
/*!**************************************************************!*\
  !*** ../../node_modules/@melloware/coloris/dist/coloris.css ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../docs/example/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../../docs/example/node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../docs/example/node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../docs/example/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../../docs/example/node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../../docs/example/node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../../docs/example/node_modules/css-loader/dist/cjs.js!./coloris.css */ \"./node_modules/css-loader/dist/cjs.js!../../node_modules/@melloware/coloris/dist/coloris.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_docs_example_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_docs_example_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _docs_example_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_docs_example_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_docs_example_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _docs_example_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_docs_example_node_modules_css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_docs_example_node_modules_css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _docs_example_node_modules_css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _docs_example_node_modules_css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://jsdraw/../../node_modules/@melloware/coloris/dist/coloris.css?");

/***/ }),

/***/ "../../src/Editor.css":
/*!****************************!*\
  !*** ../../src/Editor.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../docs/example/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../docs/example/node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../docs/example/node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../docs/example/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../docs/example/node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../docs/example/node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _docs_example_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_docs_example_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _docs_example_node_modules_css_loader_dist_cjs_js_Editor_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../docs/example/node_modules/css-loader/dist/cjs.js!./Editor.css */ \"./node_modules/css-loader/dist/cjs.js!../../src/Editor.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_docs_example_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_docs_example_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _docs_example_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_docs_example_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_docs_example_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _docs_example_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_docs_example_node_modules_css_loader_dist_cjs_js_Editor_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_docs_example_node_modules_css_loader_dist_cjs_js_Editor_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _docs_example_node_modules_css_loader_dist_cjs_js_Editor_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _docs_example_node_modules_css_loader_dist_cjs_js_Editor_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://jsdraw/../../src/Editor.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://jsdraw/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://jsdraw/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://jsdraw/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://jsdraw/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://jsdraw/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://jsdraw/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./example.ts":
/*!********************!*\
  !*** ./example.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_Editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/Editor */ \"../../src/Editor.ts\");\n/* harmony import */ var _src_styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/styles */ \"../../src/styles.js\");\n// To test importing from a parent directory\n\n\n// To test the NPM package\n//import Editor from 'js-draw';\n//import 'js-draw/styles';\n// Key in window.localStorage to save the SVG as.\nconst saveLocalStorageKey = 'lastSave';\nconst createEditor = (saveCallback) => {\n    const parentElement = document.body;\n    const editor = new _src_Editor__WEBPACK_IMPORTED_MODULE_0__[\"default\"](parentElement);\n    const toolbar = editor.addToolbar();\n    toolbar.addActionButton('Save', () => {\n        saveCallback();\n    });\n    return editor;\n};\n// Saves [editor]'s content as an SVG and displays the result.\nconst showSavePopup = (editor) => {\n    const popup = window.open();\n    if (popup === null) {\n        throw new Error('Unable to open save popup!');\n    }\n    const img = editor.toSVG();\n    const imgHTML = img.outerHTML;\n    popup.document.open();\n    popup.document.write(`\n\t\t<!DOCTYPE html>\n\t\t<html>\n\t\t<head>\n\t\t\t<meta name='viewport' content='initial-scale=1.0'/>\n\t\t\t<meta charset='utf-8'/>\n\t\t</head>\n\t\t<body>\n\t\t\t<style>\n\t\t\t\t#previewRegion {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex-direction: row;\n\t\t\t\t}\n\n\t\t\t\tsvg {\n\t\t\t\t\theight: auto;\n\t\t\t\t\twidth: auto;\n\t\t\t\t\tmax-width: 500px;\n\t\t\t\t\tmax-height: 100vh;\n\t\t\t\t\tflex-grow: 1;\n\t\t\t\t\tborder: 1px solid gray;\n\t\t\t\t}\n\n\t\t\t\ttextarea {\n\t\t\t\t\tflex-grow: 1;\n\t\t\t\t\tflex-shrink: 1;\n\t\t\t\t\twidth: auto;\n\t\t\t\t}\n\t\t\t</style>\n\t\t\t<p>\n\t\t\t\t Warning : Some browsers won't save images over 2.5-ish MiB!\n\t\t\t</p>\n\t\t\t<div id='previewRegion'>\n\t\t\t\t<p>Saving to <code>localStorage</code>...</p>\n\t\t\t</div>\n\t\t</body>\n\t\t</html>`);\n    popup.document.close();\n    // Loading the preview can be much slower than saving the image.\n    // Only do so if requested.\n    const previewRegion = popup.document.querySelector('#previewRegion');\n    const previewButton = popup.document.createElement('button');\n    previewButton.innerText = 'View generated SVG image';\n    previewButton.onclick = () => {\n        var _a;\n        const messageContainer = popup.document.createElement('p');\n        const svgTextContainer = popup.document.createElement('textarea');\n        const imagePreview = popup.document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        imagePreview.innerHTML = img.innerHTML;\n        imagePreview.setAttribute('viewBox', (_a = img.getAttribute('viewBox')) !== null && _a !== void 0 ? _a : '');\n        messageContainer.innerText = 'Preview: ';\n        svgTextContainer.value = imgHTML;\n        previewRegion.replaceChildren(messageContainer, svgTextContainer, imagePreview);\n    };\n    const downloadButton = popup.document.createElement('button');\n    downloadButton.innerText = 'Download';\n    downloadButton.onclick = () => {\n        const blob = new Blob([imgHTML], { type: 'image/svg' });\n        const objectURL = URL.createObjectURL(blob);\n        const link = popup.document.createElement('a');\n        link.href = objectURL;\n        link.innerText = 'Download';\n        // Download as: (Ref: https://stackoverflow.com/a/52814195/17055750)\n        link.setAttribute('download', 'editor-save.svg');\n        downloadButton.replaceWith(link);\n        link.click();\n        // Release URL (see section on object URLs in\n        // https://developer.mozilla.org/en-US/docs/Web/API/File_API/Using_files_from_web_applications)\n        link.remove();\n        URL.revokeObjectURL(objectURL);\n    };\n    popup.document.body.appendChild(downloadButton);\n    let localStorageSaveStatus = 'Unable to save to localStorage. ';\n    if (window.localStorage) {\n        // Save\n        window.localStorage.setItem(saveLocalStorageKey, imgHTML);\n        localStorageSaveStatus = 'Saved to localStorage! ';\n    }\n    let imageSize = `${Math.round(imgHTML.length / 1024 * 10) / 10} KiB`;\n    if (imgHTML.length > 1024 * 1024) {\n        imageSize = `${Math.round(imgHTML.length / 1024 * 10 / 1024) / 10} MiB`;\n    }\n    previewRegion.replaceChildren(popup.document.createTextNode(localStorageSaveStatus), popup.document.createTextNode(`Image size: ${imageSize}.`), previewButton);\n};\nconst startVisualErrorLog = () => {\n    const logArea = document.querySelector('#logOutput');\n    logArea.style.display = 'block';\n    logArea.value = `\n\nIf enabled, errors will be logged to this textarea.\n\n\n\t`;\n    const scrollLogToEnd = () => {\n        logArea.scrollTop = logArea.scrollHeight;\n    };\n    window.onerror = (evt) => {\n        logArea.value += '\\nError thrown: ' + evt + '\\n';\n        scrollLogToEnd();\n    };\n    const originalErrFn = console.error;\n    console.error = (...data) => {\n        originalErrFn.apply(console, data);\n        logArea.value += '\\nError logged: ' + data.join(', ') + '\\n';\n        scrollLogToEnd();\n    };\n};\n(() => {\n    const showErrorsCheckbox = document.querySelector('#alertOnError');\n    const loadFromTextarea = document.querySelector('#initialData');\n    const fileInput = document.querySelector('#initialFile');\n    const startButton = document.querySelector('#startButton');\n    const optionsScreen = document.querySelector('#editorOptions');\n    const loadFromLastSaveText = 'Load from last save (if available)';\n    const loadFromFileText = 'Load from selected file';\n    loadFromTextarea.value = loadFromLastSaveText;\n    // SVG source string\n    let sourceText = null;\n    // Clear the file input (don't autofill)\n    fileInput.value = '';\n    // Handle file uploads.\n    fileInput.onchange = () => {\n        var _a;\n        loadFromTextarea.value = '...';\n        const files = (_a = fileInput.files) !== null && _a !== void 0 ? _a : [];\n        if (files.length > 1) {\n            alert('Too many files!');\n            return;\n        }\n        if (files.length === 0) {\n            return;\n        }\n        const reader = new FileReader();\n        reader.onload = (progress => {\n            var _a;\n            if ((_a = progress.target) === null || _a === void 0 ? void 0 : _a.result) {\n                loadFromTextarea.value = loadFromFileText;\n                // The reader was started with .readAsText, so we know [result]\n                // is a string.\n                sourceText = progress.target.result;\n            }\n        });\n        reader.readAsText(files[0]);\n    };\n    startButton.onclick = () => {\n        var _a, _b;\n        const textareaData = loadFromTextarea.value;\n        const showErrors = showErrorsCheckbox.checked;\n        optionsScreen.remove();\n        if (showErrors) {\n            startVisualErrorLog();\n        }\n        const editor = createEditor(() => showSavePopup(editor));\n        sourceText !== null && sourceText !== void 0 ? sourceText : (sourceText = textareaData);\n        if (sourceText === loadFromLastSaveText) {\n            sourceText = (_b = (_a = window.localStorage) === null || _a === void 0 ? void 0 : _a.getItem(saveLocalStorageKey)) !== null && _b !== void 0 ? _b : '';\n        }\n        if (sourceText && sourceText.length > 0) {\n            editor.loadFromSVG(sourceText);\n        }\n    };\n})();\n\n\n//# sourceURL=webpack://jsdraw/./example.ts?");

/***/ }),

/***/ "../../src/Color4.ts":
/*!***************************!*\
  !*** ../../src/Color4.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Color4)\n/* harmony export */ });\nclass Color4 {\n    constructor(r, g, b, a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        this.hexString = null;\n    }\n    // Each component should be in the range [0, 1]\n    static ofRGB(red, green, blue) {\n        return new Color4(red, green, blue, 1.0);\n    }\n    static ofRGBA(red, green, blue, alpha) {\n        return new Color4(red, green, blue, alpha);\n    }\n    static fromHex(hexString) {\n        var _a;\n        // Remove starting '#' (if present)\n        hexString = ((_a = hexString.match(/^[#]?(.*)$/)) !== null && _a !== void 0 ? _a : [])[1];\n        hexString = hexString.toUpperCase();\n        if (!hexString.match(/^[0-9A-F]+$/)) {\n            throw new Error(`${hexString} is not in a valid format.`);\n        }\n        // RGBA or RGB\n        if (hexString.length === 3 || hexString.length === 4) {\n            // Each character is a component\n            const components = hexString.split('');\n            // Convert to RRGGBBAA or RRGGBB format\n            hexString = components.map(component => `${component}0`).join('');\n        }\n        if (hexString.length === 6) {\n            // Alpha component\n            hexString += 'FF';\n        }\n        const components = [];\n        for (let i = 2; i <= hexString.length; i += 2) {\n            const chunk = hexString.substring(i - 2, i);\n            components.push(parseInt(chunk, 16) / 255);\n        }\n        if (components.length !== 4) {\n            throw new Error(`Unable to parse ${hexString}: Wrong number of components.`);\n        }\n        return new Color4(components[0], components[1], components[2], components[3]);\n    }\n    // Like fromHex, but can handle additional colors if an HTML5Canvas is available.\n    static fromString(text) {\n        if (text.startsWith('#')) {\n            return Color4.fromHex(text);\n        }\n        else {\n            // Otherwise, try to use an HTML5Canvas to determine the color\n            const canvas = document.createElement('canvas');\n            canvas.width = 1;\n            canvas.height = 1;\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = text;\n            ctx.fillRect(0, 0, 1, 1);\n            const data = ctx.getImageData(0, 0, 1, 1);\n            const red = data.data[0] / 255;\n            const green = data.data[1] / 255;\n            const blue = data.data[2] / 255;\n            const alpha = data.data[3] / 255;\n            return Color4.ofRGBA(red, green, blue, alpha);\n        }\n    }\n    eq(other) {\n        if (other == null) {\n            return false;\n        }\n        return this.toHexString() === other.toHexString();\n    }\n    toHexString() {\n        if (this.hexString) {\n            return this.hexString;\n        }\n        const componentToHex = (component) => {\n            const res = Math.round(255 * component).toString(16);\n            if (res.length === 1) {\n                return `0${res}`;\n            }\n            return res;\n        };\n        const alpha = componentToHex(this.a);\n        const red = componentToHex(this.r);\n        const green = componentToHex(this.g);\n        const blue = componentToHex(this.b);\n        if (alpha === 'ff') {\n            return `#${red}${green}${blue}`;\n        }\n        this.hexString = `#${red}${green}${blue}${alpha}`;\n        return this.hexString;\n    }\n}\nColor4.transparent = Color4.ofRGBA(0, 0, 0, 0);\nColor4.red = Color4.ofRGB(1.0, 0.0, 0.0);\nColor4.green = Color4.ofRGB(0.0, 1.0, 0.0);\nColor4.blue = Color4.ofRGB(0.0, 0.0, 1.0);\nColor4.purple = Color4.ofRGB(0.5, 0.2, 0.5);\nColor4.yellow = Color4.ofRGB(1, 1, 0.1);\nColor4.clay = Color4.ofRGB(0.8, 0.4, 0.2);\nColor4.black = Color4.ofRGB(0, 0, 0);\nColor4.white = Color4.ofRGB(1, 1, 1);\n\n\n//# sourceURL=webpack://jsdraw/../../src/Color4.ts?");

/***/ }),

/***/ "../../src/Display.ts":
/*!****************************!*\
  !*** ../../src/Display.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderingMode\": () => (/* binding */ RenderingMode),\n/* harmony export */   \"default\": () => (/* binding */ Display)\n/* harmony export */ });\n/* harmony import */ var _rendering_CanvasRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rendering/CanvasRenderer */ \"../../src/rendering/CanvasRenderer.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"../../src/types.ts\");\n/* harmony import */ var _rendering_DummyRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rendering/DummyRenderer */ \"../../src/rendering/DummyRenderer.ts\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n\n\n\n\nvar RenderingMode;\n(function (RenderingMode) {\n    RenderingMode[RenderingMode[\"DummyRenderer\"] = 0] = \"DummyRenderer\";\n    RenderingMode[RenderingMode[\"CanvasRenderer\"] = 1] = \"CanvasRenderer\";\n    // SVGRenderer is not supported by the main display\n})(RenderingMode || (RenderingMode = {}));\nclass Display {\n    constructor(editor, mode, parent) {\n        this.editor = editor;\n        this.parent = parent;\n        if (mode === RenderingMode.CanvasRenderer) {\n            this.initializeCanvasRendering();\n        }\n        else if (mode === RenderingMode.DummyRenderer) {\n            this.dryInkRenderer = new _rendering_DummyRenderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](editor.viewport);\n            this.wetInkRenderer = new _rendering_DummyRenderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](editor.viewport);\n        }\n        else {\n            throw new Error(`Unknown rendering mode, ${mode}!`);\n        }\n        this.editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.DisplayResized, event => {\n            var _a;\n            if (event.kind !== _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.DisplayResized) {\n                throw new Error('Mismatched event.kinds!');\n            }\n            (_a = this.resizeSurfacesCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n    // Returns the visible width of the display (e.g. how much\n    // space the display's element takes up in the x direction\n    // in the DOM).\n    get width() {\n        return this.dryInkRenderer.displaySize().x;\n    }\n    get height() {\n        return this.dryInkRenderer.displaySize().y;\n    }\n    initializeCanvasRendering() {\n        const dryInkCanvas = document.createElement('canvas');\n        const wetInkCanvas = document.createElement('canvas');\n        const dryInkCtx = dryInkCanvas.getContext('2d');\n        const wetInkCtx = wetInkCanvas.getContext('2d');\n        this.dryInkRenderer = new _rendering_CanvasRenderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](dryInkCtx, this.editor.viewport);\n        this.wetInkRenderer = new _rendering_CanvasRenderer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](wetInkCtx, this.editor.viewport);\n        dryInkCanvas.className = 'dryInkCanvas';\n        wetInkCanvas.className = 'wetInkCanvas';\n        if (this.parent) {\n            this.parent.appendChild(dryInkCanvas);\n            this.parent.appendChild(wetInkCanvas);\n        }\n        this.resizeSurfacesCallback = () => {\n            const hasSizeMismatch = (canvas) => {\n                return canvas.clientHeight !== canvas.height || canvas.clientWidth !== canvas.width;\n            };\n            // Ensure that the drawing surfaces sizes match the\n            // canvas' sizes to prevent stretching.\n            if (hasSizeMismatch(dryInkCanvas) || hasSizeMismatch(wetInkCanvas)) {\n                dryInkCanvas.width = dryInkCanvas.clientWidth;\n                dryInkCanvas.height = dryInkCanvas.clientHeight;\n                wetInkCanvas.width = wetInkCanvas.clientWidth;\n                wetInkCanvas.height = wetInkCanvas.clientHeight;\n                this.editor.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.DisplayResized, {\n                    kind: _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.DisplayResized,\n                    newSize: _geometry_Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(this.width, this.height),\n                });\n            }\n        };\n        this.resizeSurfacesCallback();\n        this.flattenCallback = () => {\n            dryInkCtx.drawImage(wetInkCanvas, 0, 0);\n        };\n    }\n    // Clears the drawing surfaces and otherwise prepares for a rerender.\n    startRerender() {\n        var _a;\n        (_a = this.resizeSurfacesCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.wetInkRenderer.clear();\n        this.dryInkRenderer.clear();\n        return this.dryInkRenderer;\n    }\n    getDryInkRenderer() {\n        return this.dryInkRenderer;\n    }\n    getWetInkRenderer() {\n        return this.wetInkRenderer;\n    }\n    // Re-renders the contents of the wetInkRenderer onto the dryInkRenderer\n    flatten() {\n        var _a;\n        (_a = this.flattenCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/Display.ts?");

/***/ }),

/***/ "../../src/Editor.ts":
/*!***************************!*\
  !*** ../../src/Editor.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Editor\": () => (/* binding */ Editor),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _EditorImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditorImage */ \"../../src/EditorImage.ts\");\n/* harmony import */ var _tools_ToolController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools/ToolController */ \"../../src/tools/ToolController.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"../../src/types.ts\");\n/* harmony import */ var _UndoRedoHistory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UndoRedoHistory */ \"../../src/UndoRedoHistory.ts\");\n/* harmony import */ var _Viewport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Viewport */ \"../../src/Viewport.ts\");\n/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EventDispatcher */ \"../../src/EventDispatcher.ts\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _geometry_Vec3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./geometry/Vec3 */ \"../../src/geometry/Vec3.ts\");\n/* harmony import */ var _toolbar_HTMLToolbar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toolbar/HTMLToolbar */ \"../../src/toolbar/HTMLToolbar.ts\");\n/* harmony import */ var _Display__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Display */ \"../../src/Display.ts\");\n/* harmony import */ var _rendering_SVGRenderer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rendering/SVGRenderer */ \"../../src/rendering/SVGRenderer.ts\");\n/* harmony import */ var _Color4__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Color4 */ \"../../src/Color4.ts\");\n/* harmony import */ var _SVGLoader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SVGLoader */ \"../../src/SVGLoader.ts\");\n/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Pointer */ \"../../src/Pointer.ts\");\n/* harmony import */ var _geometry_Mat33__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./geometry/Mat33 */ \"../../src/geometry/Mat33.ts\");\n/* harmony import */ var _localization__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./localization */ \"../../src/localization.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Editor {\n    constructor(parent, settings = {}) {\n        var _a, _b;\n        this.localization = _localization__WEBPACK_IMPORTED_MODULE_15__.defaultEditorLocalization;\n        this.announceUndoCallback = (command) => {\n            this.announceForAccessibility(this.localization.undoAnnouncement(command.description(this.localization)));\n        };\n        this.announceRedoCallback = (command) => {\n            this.announceForAccessibility(this.localization.redoAnnouncement(command.description(this.localization)));\n        };\n        this.rerenderQueued = false;\n        this.localization = Object.assign(Object.assign({}, this.localization), settings.localization);\n        // Fill default settings.\n        this.settings = {\n            wheelEventsEnabled: (_a = settings.wheelEventsEnabled) !== null && _a !== void 0 ? _a : true,\n            renderingMode: (_b = settings.renderingMode) !== null && _b !== void 0 ? _b : _Display__WEBPACK_IMPORTED_MODULE_9__.RenderingMode.CanvasRenderer,\n            localization: this.localization,\n        };\n        this.container = document.createElement('div');\n        this.renderingRegion = document.createElement('div');\n        this.container.appendChild(this.renderingRegion);\n        this.container.className = 'imageEditorContainer';\n        this.loadingWarning = document.createElement('div');\n        this.loadingWarning.classList.add('loadingMessage');\n        this.loadingWarning.ariaLive = 'polite';\n        this.container.appendChild(this.loadingWarning);\n        this.accessibilityAnnounceArea = document.createElement('div');\n        this.accessibilityAnnounceArea.ariaLive = 'assertive';\n        this.accessibilityAnnounceArea.className = 'accessibilityAnnouncement';\n        this.container.appendChild(this.accessibilityAnnounceArea);\n        this.renderingRegion.style.touchAction = 'none';\n        this.renderingRegion.className = 'imageEditorRenderArea';\n        this.renderingRegion.setAttribute('tabIndex', '0');\n        this.renderingRegion.ariaLabel = this.localization.imageEditor;\n        this.notifier = new _EventDispatcher__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n        this.importExportViewport = new _Viewport__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.notifier);\n        this.viewport = new _Viewport__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.notifier);\n        this.display = new _Display__WEBPACK_IMPORTED_MODULE_9__[\"default\"](this, this.settings.renderingMode, this.renderingRegion);\n        this.image = new _EditorImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        this.history = new _UndoRedoHistory__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this, this.announceRedoCallback, this.announceUndoCallback);\n        this.toolController = new _tools_ToolController__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, this.localization);\n        parent.appendChild(this.container);\n        // Default to a 500x500 image\n        this.importExportViewport.updateScreenSize(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_6__.Vec2.of(500, 500));\n        this.viewport.updateScreenSize(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_6__.Vec2.of(this.display.width, this.display.height));\n        this.registerListeners();\n        this.rerender();\n        this.hideLoadingWarning();\n    }\n    // Returns a reference to this' container.\n    // Example usage:\n    //   editor.getRootElement().style.height = '500px';\n    getRootElement() {\n        return this.container;\n    }\n    // [fractionLoaded] should be a number from 0 to 1, where 1 represents completely loaded.\n    showLoadingWarning(fractionLoaded) {\n        const loadingPercent = Math.round(fractionLoaded * 100);\n        this.loadingWarning.innerText = this.localization.loading(loadingPercent);\n        this.loadingWarning.style.display = 'block';\n    }\n    hideLoadingWarning() {\n        this.loadingWarning.style.display = 'none';\n        this.announceForAccessibility(this.localization.doneLoading);\n    }\n    announceForAccessibility(message) {\n        this.accessibilityAnnounceArea.innerText = message;\n    }\n    addToolbar(defaultLayout = true) {\n        const toolbar = new _toolbar_HTMLToolbar__WEBPACK_IMPORTED_MODULE_8__[\"default\"](this, this.container, this.localization);\n        if (defaultLayout) {\n            toolbar.addDefaultToolWidgets();\n            toolbar.addDefaultActionButtons();\n        }\n        return toolbar;\n    }\n    registerListeners() {\n        const pointers = {};\n        const getPointerList = () => {\n            const nowTime = (new Date()).getTime();\n            const res = [];\n            for (const id in pointers) {\n                const maxUnupdatedTime = 2000; // Maximum time without a pointer update (ms)\n                if (pointers[id] && (nowTime - pointers[id].timeStamp) < maxUnupdatedTime) {\n                    res.push(pointers[id]);\n                }\n            }\n            return res;\n        };\n        // May be required to prevent text selection on iOS/Safari:\n        // See https://stackoverflow.com/a/70992717/17055750\n        this.renderingRegion.addEventListener('touchstart', evt => evt.preventDefault());\n        this.renderingRegion.addEventListener('pointerdown', evt => {\n            const pointer = _Pointer__WEBPACK_IMPORTED_MODULE_13__[\"default\"].ofEvent(evt, true, this.viewport);\n            pointers[pointer.id] = pointer;\n            this.renderingRegion.setPointerCapture(pointer.id);\n            const event = {\n                kind: _types__WEBPACK_IMPORTED_MODULE_2__.InputEvtType.PointerDownEvt,\n                current: pointer,\n                allPointers: getPointerList(),\n            };\n            this.toolController.dispatchInputEvent(event);\n            return true;\n        });\n        this.renderingRegion.addEventListener('pointermove', evt => {\n            var _a, _b;\n            const pointer = _Pointer__WEBPACK_IMPORTED_MODULE_13__[\"default\"].ofEvent(evt, (_b = (_a = pointers[evt.pointerId]) === null || _a === void 0 ? void 0 : _a.down) !== null && _b !== void 0 ? _b : false, this.viewport);\n            if (pointer.down) {\n                const prevData = pointers[pointer.id];\n                if (prevData) {\n                    const distanceMoved = pointer.screenPos.minus(prevData.screenPos).magnitude();\n                    // If the pointer moved less than two pixels, don't send a new event.\n                    if (distanceMoved < 2) {\n                        return;\n                    }\n                }\n                pointers[pointer.id] = pointer;\n                if (this.toolController.dispatchInputEvent({\n                    kind: _types__WEBPACK_IMPORTED_MODULE_2__.InputEvtType.PointerMoveEvt,\n                    current: pointer,\n                    allPointers: getPointerList(),\n                })) {\n                    evt.preventDefault();\n                }\n            }\n        });\n        const pointerEnd = (evt) => {\n            const pointer = _Pointer__WEBPACK_IMPORTED_MODULE_13__[\"default\"].ofEvent(evt, false, this.viewport);\n            if (!pointers[pointer.id]) {\n                return;\n            }\n            pointers[pointer.id] = pointer;\n            this.renderingRegion.releasePointerCapture(pointer.id);\n            if (this.toolController.dispatchInputEvent({\n                kind: _types__WEBPACK_IMPORTED_MODULE_2__.InputEvtType.PointerUpEvt,\n                current: pointer,\n                allPointers: getPointerList(),\n            })) {\n                evt.preventDefault();\n            }\n            delete pointers[pointer.id];\n        };\n        this.renderingRegion.addEventListener('pointerup', evt => {\n            pointerEnd(evt);\n        });\n        this.renderingRegion.addEventListener('pointercancel', evt => {\n            pointerEnd(evt);\n        });\n        this.renderingRegion.addEventListener('keydown', evt => {\n            if (this.toolController.dispatchInputEvent({\n                kind: _types__WEBPACK_IMPORTED_MODULE_2__.InputEvtType.KeyPressEvent,\n                key: evt.key,\n            })) {\n                evt.preventDefault();\n            }\n        });\n        this.container.addEventListener('wheel', evt => {\n            let delta = _geometry_Vec3__WEBPACK_IMPORTED_MODULE_7__[\"default\"].of(evt.deltaX, evt.deltaY, evt.deltaZ);\n            // Process wheel events if the ctrl key is down -- we do want to handle\n            // pinch-zooming.\n            if (!this.settings.wheelEventsEnabled && !evt.ctrlKey) {\n                return;\n            }\n            if (evt.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n                delta = delta.times(15);\n            }\n            else if (evt.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n                delta = delta.times(100);\n            }\n            if (evt.ctrlKey) {\n                delta = _geometry_Vec3__WEBPACK_IMPORTED_MODULE_7__[\"default\"].of(0, 0, evt.deltaY);\n            }\n            const pos = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_6__.Vec2.of(evt.clientX, evt.clientY);\n            if (this.toolController.dispatchInputEvent({\n                kind: _types__WEBPACK_IMPORTED_MODULE_2__.InputEvtType.WheelEvt,\n                delta,\n                screenPos: pos,\n            })) {\n                evt.preventDefault();\n                return true;\n            }\n            return false;\n        });\n        this.notifier.on(_types__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.DisplayResized, _event => {\n            this.viewport.updateScreenSize(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_6__.Vec2.of(this.display.width, this.display.height));\n        });\n        window.addEventListener('resize', () => {\n            this.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.DisplayResized, {\n                kind: _types__WEBPACK_IMPORTED_MODULE_2__.EditorEventType.DisplayResized,\n                newSize: _geometry_Vec2__WEBPACK_IMPORTED_MODULE_6__.Vec2.of(this.display.width, this.display.height),\n            });\n            this.queueRerender();\n        });\n    }\n    dispatch(command, addToHistory = true) {\n        if (addToHistory) {\n            // .push applies [command] to this\n            this.history.push(command);\n        }\n        else {\n            command.apply(this);\n        }\n        this.announceForAccessibility(command.description(this.localization));\n    }\n    // Apply a large transformation in chunks.\n    // If [apply] is false, the commands are unapplied.\n    // Triggers a re-render after each [updateChunkSize]-sized group of commands\n    // has been applied.\n    asyncApplyOrUnapplyCommands(commands, apply, updateChunkSize) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < commands.length; i += updateChunkSize) {\n                this.showLoadingWarning(i / commands.length);\n                for (let j = i; j < commands.length && j < i + updateChunkSize; j++) {\n                    const cmd = commands[j];\n                    if (apply) {\n                        cmd.apply(this);\n                    }\n                    else {\n                        cmd.unapply(this);\n                    }\n                }\n                // Re-render to show progress, but only if we're not done.\n                if (i + updateChunkSize < commands.length) {\n                    yield new Promise(resolve => {\n                        this.rerender();\n                        requestAnimationFrame(resolve);\n                    });\n                }\n            }\n            this.hideLoadingWarning();\n        });\n    }\n    asyncApplyCommands(commands, chunkSize) {\n        return this.asyncApplyOrUnapplyCommands(commands, true, chunkSize);\n    }\n    asyncUnapplyCommands(commands, chunkSize) {\n        return this.asyncApplyOrUnapplyCommands(commands, false, chunkSize);\n    }\n    queueRerender() {\n        if (!this.rerenderQueued) {\n            this.rerenderQueued = true;\n            requestAnimationFrame(() => {\n                this.rerender();\n                this.rerenderQueued = false;\n            });\n        }\n    }\n    rerender(showImageBounds = true) {\n        this.display.startRerender();\n        // Draw a rectangle around the region that will be visible on save\n        const renderer = this.display.getDryInkRenderer();\n        if (showImageBounds) {\n            const exportRectFill = { fill: _Color4__WEBPACK_IMPORTED_MODULE_11__[\"default\"].fromHex('#44444455') };\n            const exportRectStrokeWidth = 12;\n            renderer.drawRect(this.importExportViewport.visibleRect, exportRectStrokeWidth, exportRectFill);\n        }\n        this.image.render(renderer, this.viewport);\n        this.rerenderQueued = false;\n    }\n    drawWetInk(...path) {\n        for (const part of path) {\n            this.display.getWetInkRenderer().drawPath(part);\n        }\n    }\n    clearWetInk() {\n        this.display.getWetInkRenderer().clear();\n    }\n    createHTMLOverlay(overlay) {\n        overlay.classList.add('overlay');\n        this.container.appendChild(overlay);\n        return {\n            remove: () => overlay.remove(),\n        };\n    }\n    addStyleSheet(content) {\n        const styleSheet = document.createElement('style');\n        styleSheet.innerText = content;\n        this.container.appendChild(styleSheet);\n        return styleSheet;\n    }\n    // Dispatch a pen event to the currently selected tool.\n    // Intented for unit tests.\n    sendPenEvent(eventType, point, allPointers) {\n        const mainPointer = _Pointer__WEBPACK_IMPORTED_MODULE_13__[\"default\"].ofCanvasPoint(point, eventType !== _types__WEBPACK_IMPORTED_MODULE_2__.InputEvtType.PointerUpEvt, this.viewport);\n        this.toolController.dispatchInputEvent({\n            kind: eventType,\n            allPointers: allPointers !== null && allPointers !== void 0 ? allPointers : [\n                mainPointer,\n            ],\n            current: mainPointer,\n        });\n    }\n    toSVG() {\n        const importExportViewport = this.importExportViewport;\n        const svgNameSpace = 'http://www.w3.org/2000/svg';\n        const result = document.createElementNS(svgNameSpace, 'svg');\n        const renderer = new _rendering_SVGRenderer__WEBPACK_IMPORTED_MODULE_10__[\"default\"](result, importExportViewport);\n        const origTransform = importExportViewport.canvasToScreenTransform;\n        // Reset the transform to ensure that (0, 0) is (0, 0)\n        importExportViewport.resetTransform(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_14__[\"default\"].identity);\n        // Render **all** elements.\n        this.image.renderAll(renderer);\n        importExportViewport.resetTransform(origTransform);\n        // Just show the main region\n        const rect = importExportViewport.visibleRect;\n        result.setAttribute('viewBox', `${rect.x} ${rect.y} ${rect.w} ${rect.h}`);\n        result.setAttribute('width', `${rect.w}`);\n        result.setAttribute('height', `${rect.h}`);\n        console.log('res', result);\n        // Ensure the image can be identified as an SVG if downloaded.\n        // See https://jwatt.org/svg/authoring/\n        result.setAttribute('version', '1.1');\n        result.setAttribute('baseProfile', 'full');\n        result.setAttribute('xmlns', svgNameSpace);\n        return result;\n    }\n    loadFrom(loader) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.showLoadingWarning(0);\n            const imageRect = yield loader.start((component) => {\n                (new _EditorImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"].AddElementCommand(component)).apply(this);\n            }, (countProcessed, totalToProcess) => {\n                if (countProcessed % 100 === 0) {\n                    this.showLoadingWarning(countProcessed / totalToProcess);\n                    this.rerender(false);\n                    return new Promise(resolve => {\n                        requestAnimationFrame(() => resolve());\n                    });\n                }\n                return null;\n            });\n            this.hideLoadingWarning();\n            this.setImportExportRect(imageRect).apply(this);\n        });\n    }\n    // Returns the size of the visible region of the output SVG\n    getImportExportRect() {\n        return this.importExportViewport.visibleRect;\n    }\n    // Resize the output SVG\n    setImportExportRect(imageRect) {\n        const origSize = this.importExportViewport.visibleRect.size;\n        const origTransform = this.importExportViewport.canvasToScreenTransform;\n        return {\n            apply(editor) {\n                const viewport = editor.importExportViewport;\n                viewport.updateScreenSize(imageRect.size);\n                viewport.resetTransform(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_14__[\"default\"].translation(imageRect.topLeft.times(-1)));\n                editor.queueRerender();\n            },\n            unapply(editor) {\n                const viewport = editor.importExportViewport;\n                viewport.updateScreenSize(origSize);\n                viewport.resetTransform(origTransform);\n                editor.queueRerender();\n            },\n            description(localizationTable) {\n                return localizationTable.resizeOutputCommand(imageRect);\n            },\n        };\n    }\n    // Alias for loadFrom(SVGLoader.fromString).\n    // This is particularly useful when accessing a bundled version of the editor.\n    loadFromSVG(svgData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const loader = _SVGLoader__WEBPACK_IMPORTED_MODULE_12__[\"default\"].fromString(svgData);\n            yield this.loadFrom(loader);\n        });\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Editor);\n\n\n//# sourceURL=webpack://jsdraw/../../src/Editor.ts?");

/***/ }),

/***/ "../../src/EditorImage.ts":
/*!********************************!*\
  !*** ../../src/EditorImage.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageNode\": () => (/* binding */ ImageNode),\n/* harmony export */   \"default\": () => (/* binding */ EditorImage)\n/* harmony export */ });\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _element, _applyByFlattening, _a;\n\n// Handles lookup/storage of elements in the image\nclass EditorImage {\n    constructor() {\n        this.root = new ImageNode();\n    }\n    addElement(elem) {\n        return this.root.addLeaf(elem);\n    }\n    // Returns the parent of the given element, if it exists.\n    findParent(elem) {\n        const candidates = this.root.getLeavesInRegion(elem.getBBox());\n        for (const candidate of candidates) {\n            if (candidate.getContent() === elem) {\n                return candidate;\n            }\n        }\n        return null;\n    }\n    sortLeaves(leaves) {\n        leaves.sort((a, b) => a.getContent().zIndex - b.getContent().zIndex);\n    }\n    render(renderer, viewport, minFraction = 0.001) {\n        // Don't render components that are < 0.1% of the viewport.\n        const leaves = this.root.getLeavesInRegion(viewport.visibleRect, minFraction);\n        this.sortLeaves(leaves);\n        for (const leaf of leaves) {\n            // Leaves by definition have content\n            leaf.getContent().render(renderer, viewport.visibleRect);\n        }\n    }\n    // Renders all nodes, even ones not within the viewport\n    renderAll(renderer) {\n        const leaves = this.root.getLeaves();\n        this.sortLeaves(leaves);\n        for (const leaf of leaves) {\n            leaf.getContent().render(renderer, leaf.getBBox());\n        }\n    }\n    getElementsIntersectingRegion(region) {\n        const leaves = this.root.getLeavesInRegion(region);\n        this.sortLeaves(leaves);\n        return leaves.map(leaf => leaf.getContent());\n    }\n}\n// A Command that can access private [EditorImage] functionality\nEditorImage.AddElementCommand = (_a = class {\n        // If [applyByFlattening], then the rendered content of this element\n        // is present on the display's wet ink canvas. As such, no re-render is necessary\n        // the first time this command is applied (the surfaces are joined instead).\n        constructor(element, applyByFlattening = false) {\n            _element.set(this, void 0);\n            _applyByFlattening.set(this, false);\n            __classPrivateFieldSet(this, _element, element, \"f\");\n            __classPrivateFieldSet(this, _applyByFlattening, applyByFlattening, \"f\");\n        }\n        apply(editor) {\n            editor.image.addElement(__classPrivateFieldGet(this, _element, \"f\"));\n            if (!__classPrivateFieldGet(this, _applyByFlattening, \"f\")) {\n                editor.queueRerender();\n            }\n            else {\n                __classPrivateFieldSet(this, _applyByFlattening, false, \"f\");\n                editor.display.flatten();\n            }\n        }\n        unapply(editor) {\n            const container = editor.image.findParent(__classPrivateFieldGet(this, _element, \"f\"));\n            container === null || container === void 0 ? void 0 : container.remove();\n            editor.queueRerender();\n        }\n        description(localization) {\n            return localization.addElementAction(__classPrivateFieldGet(this, _element, \"f\").description(localization));\n        }\n    },\n    _element = new WeakMap(),\n    _applyByFlattening = new WeakMap(),\n    _a);\nclass ImageNode {\n    constructor(parent = null) {\n        this.parent = parent;\n        this.targetChildCount = 30;\n        this.children = [];\n        this.bbox = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty;\n        this.content = null;\n        this.minZIndex = null;\n        this.maxZIndex = null;\n    }\n    getContent() {\n        return this.content;\n    }\n    getParent() {\n        return this.parent;\n    }\n    getChildrenInRegion(region) {\n        return this.children.filter(child => {\n            return child.getBBox().intersects(region);\n        });\n    }\n    // Returns a list of `ImageNode`s with content (and thus no children).\n    getLeavesInRegion(region, minFractionOfRegion = 0) {\n        const result = [];\n        // Don't render if too small\n        if (this.bbox.maxDimension / region.maxDimension <= minFractionOfRegion) {\n            return [];\n        }\n        if (this.content !== null && this.getBBox().intersects(region)) {\n            result.push(this);\n        }\n        const children = this.getChildrenInRegion(region);\n        for (const child of children) {\n            result.push(...child.getLeavesInRegion(region, minFractionOfRegion));\n        }\n        return result;\n    }\n    // Returns a list of leaves with this as an ancestor.\n    // Like getLeavesInRegion, but does not check whether ancestors are in a given rectangle\n    getLeaves() {\n        if (this.content) {\n            return [this];\n        }\n        const result = [];\n        for (const child of this.children) {\n            result.push(...child.getLeaves());\n        }\n        return result;\n    }\n    addLeaf(leaf) {\n        if (this.content === null && this.children.length === 0) {\n            this.content = leaf;\n            this.recomputeBBox(true);\n            return this;\n        }\n        if (this.content !== null) {\n            console.assert(this.children.length === 0);\n            const contentNode = new ImageNode(this);\n            contentNode.content = this.content;\n            this.content = null;\n            this.children.push(contentNode);\n            contentNode.recomputeBBox(false);\n        }\n        // If this node is contained within the leaf, make this and the leaf\n        // share a parent.\n        const leafBBox = leaf.getBBox();\n        if (leafBBox.containsRect(this.getBBox())) {\n            // Create a node for this' children and for the new content..\n            const nodeForNewLeaf = new ImageNode(this);\n            const nodeForChildren = new ImageNode(this);\n            nodeForChildren.children = this.children;\n            this.children = [nodeForNewLeaf, nodeForChildren];\n            nodeForChildren.recomputeBBox(true);\n            return nodeForNewLeaf.addLeaf(leaf);\n        }\n        const containingNodes = this.children.filter(child => child.getBBox().containsRect(leafBBox));\n        // Does the leaf already fit within one of the children?\n        if (containingNodes.length > 0 && this.children.length >= this.targetChildCount) {\n            // Sort the containers in ascending order by area\n            containingNodes.sort((a, b) => a.getBBox().area - b.getBBox().area);\n            // Choose the smallest child that contains the new element.\n            const result = containingNodes[0].addLeaf(leaf);\n            result.rebalance();\n            return result;\n        }\n        const newNode = new ImageNode(this);\n        this.children.push(newNode);\n        newNode.content = leaf;\n        newNode.recomputeBBox(true);\n        return newNode;\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    // Recomputes this' bounding box. If [bubbleUp], also recompute\n    // this' ancestors bounding boxes. This also re-computes this' bounding box\n    // in the z-direction (z-indicies).\n    recomputeBBox(bubbleUp) {\n        var _a, _b, _c;\n        const oldBBox = this.bbox;\n        if (this.content !== null) {\n            this.bbox = this.content.getBBox();\n            this.minZIndex = this.content.zIndex;\n            this.maxZIndex = this.content.zIndex;\n        }\n        else {\n            this.bbox = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty;\n            this.minZIndex = null;\n            this.maxZIndex = null;\n            let isFirst = true;\n            for (const child of this.children) {\n                if (isFirst) {\n                    this.bbox = child.getBBox();\n                    isFirst = false;\n                }\n                else {\n                    this.bbox = this.bbox.union(child.getBBox());\n                }\n                (_a = this.minZIndex) !== null && _a !== void 0 ? _a : (this.minZIndex = child.minZIndex);\n                (_b = this.maxZIndex) !== null && _b !== void 0 ? _b : (this.maxZIndex = child.maxZIndex);\n                if (child.minZIndex !== null && this.minZIndex !== null) {\n                    this.minZIndex = Math.min(child.minZIndex, this.minZIndex);\n                }\n                if (child.maxZIndex !== null && this.maxZIndex !== null) {\n                    this.maxZIndex = Math.max(child.maxZIndex, this.maxZIndex);\n                }\n            }\n        }\n        if (bubbleUp && !oldBBox.eq(this.bbox)) {\n            (_c = this.parent) === null || _c === void 0 ? void 0 : _c.recomputeBBox(true);\n        }\n    }\n    rebalance() {\n        // If the current node is its parent's only child,\n        if (this.parent && this.parent.children.length === 1) {\n            console.assert(this.parent.content === null);\n            console.assert(this.parent.children[0] === this);\n            // Remove this' parent, if this' parent isn't the root.\n            const oldParent = this.parent;\n            if (oldParent.parent !== null) {\n                oldParent.children = [];\n                this.parent = oldParent.parent;\n                this.parent.children.push(this);\n                oldParent.parent = null;\n                this.parent.recomputeBBox(false);\n            }\n            else if (this.content === null) {\n                // Remove this and transfer this' children to the parent.\n                this.parent.children = this.children;\n                this.parent = null;\n            }\n        }\n    }\n    // Remove this node and all of its children\n    remove() {\n        this.minZIndex = null;\n        this.maxZIndex = null;\n        if (!this.parent) {\n            this.content = null;\n            this.children = [];\n            return;\n        }\n        const oldChildCount = this.parent.children.length;\n        this.parent.children = this.parent.children.filter(node => {\n            return node !== this;\n        });\n        console.assert(this.parent.children.length === oldChildCount - 1);\n        this.parent.children.forEach(child => {\n            child.rebalance();\n        });\n        this.parent.recomputeBBox(true);\n        // Invalidate/disconnect this.\n        this.content = null;\n        this.parent = null;\n        this.children = [];\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/EditorImage.ts?");

/***/ }),

/***/ "../../src/EventDispatcher.ts":
/*!************************************!*\
  !*** ../../src/EventDispatcher.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EventDispatcher)\n/* harmony export */ });\n// Code shared with Joplin\n// EventKeyType is used to distinguish events (e.g. a 'ClickEvent' vs a 'TouchEvent')\n// while EventMessageType is the type of the data sent with an event (can be `void`)\nclass EventDispatcher {\n    constructor() {\n        this.listeners = {};\n    }\n    dispatch(eventName, event) {\n        const listenerList = this.listeners[eventName];\n        if (listenerList) {\n            for (let i = 0; i < listenerList.length; i++) {\n                listenerList[i](event);\n            }\n        }\n    }\n    on(eventName, callback) {\n        if (!this.listeners[eventName])\n            this.listeners[eventName] = [];\n        this.listeners[eventName].push(callback);\n        return {\n            // Retuns false if the listener has already been removed, true otherwise.\n            remove: () => {\n                const originalListeners = this.listeners[eventName];\n                this.off(eventName, callback);\n                return originalListeners.length !== this.listeners[eventName].length;\n            },\n        };\n    }\n    // Equivalent to calling .remove() on the object returned by .on\n    off(eventName, callback) {\n        const listeners = this.listeners[eventName];\n        if (!listeners)\n            return;\n        // Replace the current list of listeners with a new, shortened list.\n        // This allows any iterators over this.listeners to continue iterating\n        // without skipping elements.\n        this.listeners[eventName] = listeners.filter(otherCallback => otherCallback !== callback);\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/EventDispatcher.ts?");

/***/ }),

/***/ "../../src/Pointer.ts":
/*!****************************!*\
  !*** ../../src/Pointer.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PointerDevice\": () => (/* binding */ PointerDevice),\n/* harmony export */   \"default\": () => (/* binding */ Pointer)\n/* harmony export */ });\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n\nvar PointerDevice;\n(function (PointerDevice) {\n    PointerDevice[PointerDevice[\"Pen\"] = 0] = \"Pen\";\n    PointerDevice[PointerDevice[\"Eraser\"] = 1] = \"Eraser\";\n    PointerDevice[PointerDevice[\"Touch\"] = 2] = \"Touch\";\n    PointerDevice[PointerDevice[\"Mouse\"] = 3] = \"Mouse\";\n    PointerDevice[PointerDevice[\"Other\"] = 4] = \"Other\";\n})(PointerDevice || (PointerDevice = {}));\n// Provides a snapshot containing information about a pointer. A Pointer\n// object is immutable --- it will not be updated when the pointer's information changes.\nclass Pointer {\n    constructor(\n    // The (x, y) position of the pointer relative to the top-left corner\n    // of the visible canvas.\n    screenPos, \n    // Position of the pointer relative to the top left corner of the drawing\n    // surface.\n    canvasPos, pressure, isPrimary, down, device, \n    // Unique ID for the pointer\n    id, \n    // Numeric timestamp (milliseconds, as from (new Date).getTime())\n    timeStamp) {\n        this.screenPos = screenPos;\n        this.canvasPos = canvasPos;\n        this.pressure = pressure;\n        this.isPrimary = isPrimary;\n        this.down = down;\n        this.device = device;\n        this.id = id;\n        this.timeStamp = timeStamp;\n    }\n    static ofEvent(evt, isDown, viewport) {\n        var _a, _b;\n        const screenPos = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(evt.offsetX, evt.offsetY);\n        const pointerTypeToDevice = {\n            'mouse': PointerDevice.Mouse,\n            'pen': PointerDevice.Pen,\n            'touch': PointerDevice.Touch,\n        };\n        let device = (_a = pointerTypeToDevice[evt.pointerType]) !== null && _a !== void 0 ? _a : PointerDevice.Other;\n        const eraserButtonMask = 0x20;\n        if (device === PointerDevice.Pen && (evt.buttons & eraserButtonMask) !== 0) {\n            device = PointerDevice.Eraser;\n        }\n        const timeStamp = (new Date()).getTime();\n        const canvasPos = viewport.roundPoint(viewport.screenToCanvas(screenPos));\n        return new Pointer(screenPos, canvasPos, (_b = evt.pressure) !== null && _b !== void 0 ? _b : null, evt.isPrimary, isDown, device, evt.pointerId, timeStamp);\n    }\n    // Create a new Pointer from a point on the canvas.\n    // Intended for unit tests.\n    static ofCanvasPoint(canvasPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null) {\n        const screenPos = viewport.canvasToScreen(canvasPos);\n        const timeStamp = (new Date()).getTime();\n        return new Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/Pointer.ts?");

/***/ }),

/***/ "../../src/SVGLoader.ts":
/*!******************************!*\
  !*** ../../src/SVGLoader.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SVGLoader),\n/* harmony export */   \"defaultSVGViewRect\": () => (/* binding */ defaultSVGViewRect)\n/* harmony export */ });\n/* harmony import */ var _Color4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color4 */ \"../../src/Color4.ts\");\n/* harmony import */ var _components_Stroke__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Stroke */ \"../../src/components/Stroke.ts\");\n/* harmony import */ var _components_SVGGlobalAttributesObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/SVGGlobalAttributesObject */ \"../../src/components/SVGGlobalAttributesObject.ts\");\n/* harmony import */ var _components_UnknownSVGObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/UnknownSVGObject */ \"../../src/components/UnknownSVGObject.ts\");\n/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometry/Path */ \"../../src/geometry/Path.ts\");\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n// Size of a loaded image if no size is specified.\nconst defaultSVGViewRect = new _geometry_Rect2__WEBPACK_IMPORTED_MODULE_5__[\"default\"](0, 0, 500, 500);\nclass SVGLoader {\n    constructor(source, onFinish) {\n        this.source = source;\n        this.onFinish = onFinish;\n        this.onAddComponent = null;\n        this.onProgress = null;\n        this.processedCount = 0;\n        this.totalToProcess = 0;\n    }\n    getStyle(node) {\n        var _a, _b, _c;\n        const style = {\n            fill: _Color4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].transparent,\n        };\n        const fillAttribute = (_a = node.getAttribute('fill')) !== null && _a !== void 0 ? _a : node.style.fill;\n        if (fillAttribute) {\n            try {\n                style.fill = _Color4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromString(fillAttribute);\n            }\n            catch (e) {\n                console.error('Unknown fill color,', fillAttribute);\n            }\n        }\n        const strokeAttribute = (_b = node.getAttribute('stroke')) !== null && _b !== void 0 ? _b : node.style.stroke;\n        const strokeWidthAttr = (_c = node.getAttribute('stroke-width')) !== null && _c !== void 0 ? _c : node.style.strokeWidth;\n        if (strokeAttribute) {\n            try {\n                let width = parseFloat(strokeWidthAttr !== null && strokeWidthAttr !== void 0 ? strokeWidthAttr : '1');\n                if (!isFinite(width)) {\n                    width = 0;\n                }\n                style.stroke = {\n                    width,\n                    color: _Color4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromString(strokeAttribute),\n                };\n            }\n            catch (e) {\n                console.error('Error parsing stroke data:', e);\n            }\n        }\n        return style;\n    }\n    strokeDataFromElem(node) {\n        var _a;\n        const result = [];\n        const pathData = (_a = node.getAttribute('d')) !== null && _a !== void 0 ? _a : '';\n        const style = this.getStyle(node);\n        // Break the path into chunks at each moveTo ('M') command:\n        const parts = pathData.split('M');\n        let isFirst = true;\n        for (const part of parts) {\n            // Skip effective no-ops -- moveTos without additional commands.\n            const isNoOpMoveTo = /^[0-9., \\t\\n]+$/.exec(part);\n            if (part !== '' && !isNoOpMoveTo) {\n                // We split the path by moveTo commands, so add the 'M' back in\n                // if it was present.\n                const current = !isFirst ? `M${part}` : part;\n                const path = _geometry_Path__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromString(current);\n                const spec = path.toRenderable(style);\n                result.push(spec);\n            }\n            isFirst = false;\n        }\n        return result;\n    }\n    // Adds a stroke with a single path\n    addPath(node) {\n        var _a;\n        let elem;\n        try {\n            const strokeData = this.strokeDataFromElem(node);\n            elem = new _components_Stroke__WEBPACK_IMPORTED_MODULE_1__[\"default\"](strokeData);\n        }\n        catch (e) {\n            console.error('Invalid path in node', node, '\\nError:', e, '\\nAdding as an unknown object.');\n            elem = new _components_UnknownSVGObject__WEBPACK_IMPORTED_MODULE_3__[\"default\"](node);\n        }\n        (_a = this.onAddComponent) === null || _a === void 0 ? void 0 : _a.call(this, elem);\n    }\n    addUnknownNode(node) {\n        var _a;\n        const component = new _components_UnknownSVGObject__WEBPACK_IMPORTED_MODULE_3__[\"default\"](node);\n        (_a = this.onAddComponent) === null || _a === void 0 ? void 0 : _a.call(this, component);\n    }\n    updateViewBox(node) {\n        const viewBoxAttr = node.getAttribute('viewBox');\n        if (this.rootViewBox || !viewBoxAttr) {\n            return;\n        }\n        const components = viewBoxAttr.split(/[ \\t,]/);\n        const x = parseFloat(components[0]);\n        const y = parseFloat(components[1]);\n        const width = parseFloat(components[2]);\n        const height = parseFloat(components[3]);\n        if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {\n            return;\n        }\n        this.rootViewBox = new _geometry_Rect2__WEBPACK_IMPORTED_MODULE_5__[\"default\"](x, y, width, height);\n    }\n    updateSVGAttrs(node) {\n        var _a;\n        (_a = this.onAddComponent) === null || _a === void 0 ? void 0 : _a.call(this, new _components_SVGGlobalAttributesObject__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.getSourceAttrs(node)));\n    }\n    visit(node) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.totalToProcess += node.childElementCount;\n            switch (node.tagName.toLowerCase()) {\n                case 'g':\n                    // Continue -- visit the node's children.\n                    break;\n                case 'path':\n                    this.addPath(node);\n                    break;\n                case 'svg':\n                    this.updateViewBox(node);\n                    this.updateSVGAttrs(node);\n                    break;\n                default:\n                    console.warn('Unknown SVG element,', node);\n                    if (!(node instanceof SVGElement)) {\n                        console.warn('Element', node, 'is not an SVGElement! Continuing anyway.');\n                    }\n                    this.addUnknownNode(node);\n                    return;\n            }\n            for (const child of node.children) {\n                yield this.visit(child);\n            }\n            this.processedCount++;\n            yield ((_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, this.processedCount, this.totalToProcess));\n        });\n    }\n    // Get SVG element attributes (e.g. xlink=...)\n    getSourceAttrs(node) {\n        return node.getAttributeNames().map(attr => {\n            return [attr, node.getAttribute(attr)];\n        });\n    }\n    start(onAddComponent, onProgress) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.onAddComponent = onAddComponent;\n            this.onProgress = onProgress;\n            // Estimate the number of tags to process.\n            this.totalToProcess = this.source.childElementCount;\n            this.processedCount = 0;\n            this.rootViewBox = null;\n            yield this.visit(this.source);\n            const viewBox = this.rootViewBox;\n            let result = defaultSVGViewRect;\n            if (viewBox) {\n                result = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_5__[\"default\"].of(viewBox);\n            }\n            (_a = this.onFinish) === null || _a === void 0 ? void 0 : _a.call(this);\n            return result;\n        });\n    }\n    // TODO: Handling unsafe data! Tripple-check that this is secure!\n    static fromString(text) {\n        var _a, _b;\n        const sandbox = document.createElement('iframe');\n        sandbox.src = 'about:blank';\n        sandbox.setAttribute('sandbox', 'allow-same-origin');\n        sandbox.setAttribute('csp', 'default-src \\'about:blank\\'');\n        sandbox.style.display = 'none';\n        // Required to access the frame's DOM. See https://stackoverflow.com/a/17777943/17055750\n        document.body.appendChild(sandbox);\n        if (!sandbox.hasAttribute('sandbox')) {\n            sandbox.remove();\n            throw new Error('SVG loading iframe is not sandboxed.');\n        }\n        // Try running JavaScript within the iframe\n        const sandboxDoc = (_b = (_a = sandbox.contentWindow) === null || _a === void 0 ? void 0 : _a.document) !== null && _b !== void 0 ? _b : sandbox.contentDocument;\n        if (sandboxDoc == null)\n            throw new Error('Unable to open a sandboxed iframe!');\n        sandboxDoc.open();\n        sandboxDoc.write(`\n\t\t\t<!DOCTYPE html>\n\t\t\t<html>\n\t\t\t\t<head>\n\t\t\t\t\t<title>SVG Loading Sandbox</title>\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<script>\n\t\t\t\t\t\tconsole.error('JavaScript should not be able to run here!');\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'The SVG sandbox is broken! Please double-check the sandboxing setting.'\n\t\t\t\t\t\t);\n\t\t\t\t\t</script>\n\t\t\t\t</body>\n\t\t\t</html>\n\t\t`);\n        sandboxDoc.close();\n        const svgElem = sandboxDoc.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svgElem.innerHTML = text;\n        return new SVGLoader(svgElem, () => {\n            sandbox.remove();\n        });\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/SVGLoader.ts?");

/***/ }),

/***/ "../../src/UndoRedoHistory.ts":
/*!************************************!*\
  !*** ../../src/UndoRedoHistory.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"../../src/types.ts\");\n\nclass UndoRedoHistory {\n    constructor(editor, announceRedoCallback, announceUndoCallback) {\n        this.editor = editor;\n        this.announceRedoCallback = announceRedoCallback;\n        this.announceUndoCallback = announceUndoCallback;\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n    fireUpdateEvent() {\n        this.editor.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.UndoRedoStackUpdated, {\n            kind: _types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.UndoRedoStackUpdated,\n            undoStackSize: this.undoStack.length,\n            redoStackSize: this.redoStack.length,\n        });\n    }\n    // Adds the given command to this and applies it to the editor.\n    push(command, apply = true) {\n        if (apply) {\n            command.apply(this.editor);\n        }\n        this.undoStack.push(command);\n        this.redoStack = [];\n        this.fireUpdateEvent();\n    }\n    // Remove the last command from this' undo stack and apply it.\n    undo() {\n        const command = this.undoStack.pop();\n        if (command) {\n            this.redoStack.push(command);\n            command.unapply(this.editor);\n            this.announceUndoCallback(command);\n        }\n        this.fireUpdateEvent();\n    }\n    redo() {\n        const command = this.redoStack.pop();\n        if (command) {\n            this.undoStack.push(command);\n            command.apply(this.editor);\n            this.announceRedoCallback(command);\n        }\n        this.fireUpdateEvent();\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UndoRedoHistory);\n\n\n//# sourceURL=webpack://jsdraw/../../src/UndoRedoHistory.ts?");

/***/ }),

/***/ "../../src/Viewport.ts":
/*!*****************************!*\
  !*** ../../src/Viewport.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Viewport\": () => (/* binding */ Viewport),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry/Mat33 */ \"../../src/geometry/Mat33.ts\");\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _geometry_Vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry/Vec3 */ \"../../src/geometry/Vec3.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"../../src/types.ts\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _inverseTransform, _a;\n\n\n\n\n\nclass Viewport {\n    constructor(notifier) {\n        this.notifier = notifier;\n        this.resetTransform(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity);\n        this.screenRect = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__[\"default\"].empty;\n    }\n    updateScreenSize(screenSize) {\n        this.screenRect = this.screenRect.resizedTo(screenSize);\n    }\n    get visibleRect() {\n        return this.screenRect.transformedBoundingBox(this.inverseTransform);\n    }\n    // the given point, but in canvas coordinates\n    screenToCanvas(screenPoint) {\n        return this.inverseTransform.transformVec2(screenPoint);\n    }\n    canvasToScreen(canvasPoint) {\n        return this.transform.transformVec2(canvasPoint);\n    }\n    // Updates the transformation directly. Using ViewportTransform is preferred.\n    // [newTransform] should map from canvas coordinates to screen coordinates.\n    resetTransform(newTransform) {\n        this.transform = newTransform;\n        this.inverseTransform = newTransform.inverse();\n        this.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_4__.EditorEventType.ViewportChanged, {\n            kind: _types__WEBPACK_IMPORTED_MODULE_4__.EditorEventType.ViewportChanged,\n            newTransform,\n        });\n    }\n    get screenToCanvasTransform() {\n        return this.inverseTransform;\n    }\n    get canvasToScreenTransform() {\n        return this.transform;\n    }\n    // Returns the amount a vector on the canvas is scaled to become a vector on the screen.\n    getScaleFactor() {\n        // Use transformVec3 to avoid translating the vector\n        return this.transform.transformVec3(_geometry_Vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"].unitX).magnitude();\n    }\n    // Returns the angle of the canvas in radians\n    getRotationAngle() {\n        return this.transform.transformVec3(_geometry_Vec3__WEBPACK_IMPORTED_MODULE_3__[\"default\"].unitX).angle();\n    }\n    // The separate function type definition seems necessary here.\n    // See https://stackoverflow.com/a/58163623/17055750.\n    // eslint-disable-next-line no-dupe-class-members\n    static roundPoint(point, tolerance) {\n        const scaleFactor = Math.pow(10, Math.floor(Math.log10(tolerance)));\n        const roundComponent = (component) => {\n            return Math.round(component / scaleFactor) * scaleFactor;\n        };\n        if (typeof point === 'number') {\n            return roundComponent(point);\n        }\n        return point.map(roundComponent);\n    }\n    // Round a point with a tolerance of 1 screen unit.\n    roundPoint(point) {\n        return Viewport.roundPoint(point, 1 / this.getScaleFactor());\n    }\n}\n// Command that translates/scales the viewport.\nViewport.ViewportTransform = (_a = class {\n        constructor(transform) {\n            this.transform = transform;\n            _inverseTransform.set(this, void 0);\n            __classPrivateFieldSet(this, _inverseTransform, transform.inverse(), \"f\");\n        }\n        apply(editor) {\n            const viewport = editor.viewport;\n            viewport.resetTransform(viewport.transform.rightMul(this.transform));\n            editor.queueRerender();\n        }\n        unapply(editor) {\n            const viewport = editor.viewport;\n            viewport.resetTransform(viewport.transform.rightMul(__classPrivateFieldGet(this, _inverseTransform, \"f\")));\n            editor.queueRerender();\n        }\n        description(localizationTable) {\n            const result = [];\n            // Describe the transformation's affect on the viewport (note that transformation transforms\n            // the **elements** within the viewport). Assumes the transformation only does rotation/scale/translation.\n            const origVec = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_2__.Vec2.unitX;\n            const linearTransformedVec = this.transform.transformVec3(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_2__.Vec2.unitX);\n            const affineTransformedVec = this.transform.transformVec2(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_2__.Vec2.unitX);\n            const scale = linearTransformedVec.magnitude();\n            const rotation = 180 / Math.PI * linearTransformedVec.angle();\n            const translation = affineTransformedVec.minus(origVec);\n            if (scale > 1.2) {\n                result.push(localizationTable.zoomedIn);\n            }\n            else if (scale < 0.8) {\n                result.push(localizationTable.zoomedOut);\n            }\n            if (Math.floor(Math.abs(rotation)) > 0) {\n                result.push(localizationTable.rotatedBy(Math.round(rotation)));\n            }\n            const minTranslation = 1e-4;\n            if (translation.x > minTranslation) {\n                result.push(localizationTable.movedLeft);\n            }\n            else if (translation.x < -minTranslation) {\n                result.push(localizationTable.movedRight);\n            }\n            if (translation.y < minTranslation) {\n                result.push(localizationTable.movedDown);\n            }\n            else if (translation.y > minTranslation) {\n                result.push(localizationTable.movedUp);\n            }\n            return result.join('; ');\n        }\n    },\n    _inverseTransform = new WeakMap(),\n    _a);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Viewport);\n\n\n//# sourceURL=webpack://jsdraw/../../src/Viewport.ts?");

/***/ }),

/***/ "../../src/commands/Erase.ts":
/*!***********************************!*\
  !*** ../../src/commands/Erase.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Erase)\n/* harmony export */ });\n/* harmony import */ var _EditorImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditorImage */ \"../../src/EditorImage.ts\");\n\nclass Erase {\n    constructor(toRemove) {\n        // Clone the list\n        this.toRemove = toRemove.map(elem => elem);\n    }\n    apply(editor) {\n        for (const part of this.toRemove) {\n            const parent = editor.image.findParent(part);\n            if (parent) {\n                parent.remove();\n            }\n        }\n        editor.queueRerender();\n    }\n    unapply(editor) {\n        for (const part of this.toRemove) {\n            if (!editor.image.findParent(part)) {\n                new _EditorImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"].AddElementCommand(part).apply(editor);\n            }\n        }\n        editor.queueRerender();\n    }\n    description(localizationTable) {\n        if (this.toRemove.length === 0) {\n            return localizationTable.erasedNoElements;\n        }\n        let description = this.toRemove[0].description(localizationTable);\n        for (const elem of this.toRemove) {\n            if (elem.description(localizationTable) !== description) {\n                description = localizationTable.elements;\n                break;\n            }\n        }\n        return localizationTable.eraseAction(description, this.toRemove.length);\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/commands/Erase.ts?");

/***/ }),

/***/ "../../src/commands/localization.ts":
/*!******************************************!*\
  !*** ../../src/commands/localization.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultCommandLocalization\": () => (/* binding */ defaultCommandLocalization)\n/* harmony export */ });\nconst defaultCommandLocalization = {\n    updatedViewport: 'Transformed Viewport',\n    transformedElements: (elemCount) => `Transformed ${elemCount} element${elemCount === 1 ? '' : 's'}`,\n    resizeOutputCommand: (newSize) => `Resized image to ${newSize.w}x${newSize.h}`,\n    addElementAction: (componentDescription) => `Added ${componentDescription}`,\n    eraseAction: (componentDescription, numElems) => `Erased ${numElems} ${componentDescription}`,\n    elements: 'Elements',\n    erasedNoElements: 'Erased nothing',\n    rotatedBy: (degrees) => `Rotated by ${Math.abs(degrees)} degrees ${degrees < 0 ? 'clockwise' : 'counter-clockwise'}`,\n    movedLeft: 'Moved left',\n    movedUp: 'Moved up',\n    movedDown: 'Moved down',\n    movedRight: 'Moved right',\n    zoomedOut: 'Zoomed out',\n    zoomedIn: 'Zoomed in',\n    selectedElements: (count) => `Selected ${count} element${count === 1 ? '' : 's'}`,\n};\n\n\n//# sourceURL=webpack://jsdraw/../../src/commands/localization.ts?");

/***/ }),

/***/ "../../src/components/AbstractComponent.ts":
/*!*************************************************!*\
  !*** ../../src/components/AbstractComponent.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AbstractComponent)\n/* harmony export */ });\n/* harmony import */ var _EditorImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditorImage */ \"../../src/EditorImage.ts\");\n\nclass AbstractComponent {\n    constructor() {\n        this.lastChangedTime = (new Date()).getTime();\n        this.zIndex = AbstractComponent.zIndexCounter++;\n    }\n    getBBox() {\n        return this.contentBBox;\n    }\n    // Returns a command that, when applied, transforms this by [affineTransfm] and\n    // updates the editor.\n    transformBy(affineTransfm) {\n        const updateTransform = (editor, newTransfm) => {\n            // Any parent should have only one direct child.\n            const parent = editor.image.findParent(this);\n            let hadParent = false;\n            if (parent) {\n                parent.remove();\n                hadParent = true;\n            }\n            this.applyTransformation(newTransfm);\n            // Add the element back to the document.\n            if (hadParent) {\n                new _EditorImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"].AddElementCommand(this).apply(editor);\n            }\n        };\n        const origZIndex = this.zIndex;\n        return {\n            apply: (editor) => {\n                this.zIndex = AbstractComponent.zIndexCounter++;\n                updateTransform(editor, affineTransfm);\n                editor.queueRerender();\n            },\n            unapply: (editor) => {\n                this.zIndex = origZIndex;\n                updateTransform(editor, affineTransfm.inverse());\n                editor.queueRerender();\n            },\n            description(localizationTable) {\n                return localizationTable.transformedElements(1);\n            },\n        };\n    }\n}\n// Topmost z-index\nAbstractComponent.zIndexCounter = 0;\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/AbstractComponent.ts?");

/***/ }),

/***/ "../../src/components/SVGGlobalAttributesObject.ts":
/*!*********************************************************!*\
  !*** ../../src/components/SVGGlobalAttributesObject.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SVGGlobalAttributesObject)\n/* harmony export */ });\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _rendering_SVGRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/SVGRenderer */ \"../../src/rendering/SVGRenderer.ts\");\n/* harmony import */ var _AbstractComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent */ \"../../src/components/AbstractComponent.ts\");\n\n\n\n// Stores global SVG attributes (e.g. namespace identifiers.)\nclass SVGGlobalAttributesObject extends _AbstractComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    constructor(attrs) {\n        super();\n        this.attrs = attrs;\n        this.contentBBox = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty;\n    }\n    render(canvas, _visibleRect) {\n        if (!(canvas instanceof _rendering_SVGRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) {\n            // Don't draw unrenderable objects if we can't\n            return;\n        }\n        console.log('Rendering to SVG.', this.attrs);\n        for (const [attr, value] of this.attrs) {\n            canvas.setRootSVGAttribute(attr, value);\n        }\n    }\n    intersects(_lineSegment) {\n        return false;\n    }\n    applyTransformation(_affineTransfm) {\n    }\n    description(localization) {\n        return localization.svgObject;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/SVGGlobalAttributesObject.ts?");

/***/ }),

/***/ "../../src/components/Stroke.ts":
/*!**************************************!*\
  !*** ../../src/components/Stroke.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Stroke)\n/* harmony export */ });\n/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Path */ \"../../src/geometry/Path.ts\");\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _AbstractComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent */ \"../../src/components/AbstractComponent.ts\");\n\n\n\nclass Stroke extends _AbstractComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    constructor(parts) {\n        var _a;\n        super();\n        this.parts = parts.map(section => {\n            const path = _geometry_Path__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromRenderable(section);\n            const pathBBox = this.bboxForPart(path.bbox, section.style);\n            if (!this.contentBBox) {\n                this.contentBBox = pathBBox;\n            }\n            else {\n                this.contentBBox = this.contentBBox.union(pathBBox);\n            }\n            return {\n                path,\n                bbox: pathBBox,\n                // To implement RenderablePathSpec\n                startPoint: path.startPoint,\n                style: section.style,\n                commands: path.parts,\n            };\n        });\n        (_a = this.contentBBox) !== null && _a !== void 0 ? _a : (this.contentBBox = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__[\"default\"].empty);\n    }\n    intersects(line) {\n        for (const part of this.parts) {\n            if (part.path.intersection(line).length > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    render(canvas, visibleRect) {\n        canvas.startObject(this.getBBox());\n        for (const part of this.parts) {\n            const bbox = part.bbox;\n            if (!visibleRect || bbox.intersects(visibleRect)) {\n                canvas.drawPath(part);\n            }\n        }\n        canvas.endObject();\n    }\n    // Grows the bounding box for a given stroke part based on that part's style.\n    bboxForPart(origBBox, style) {\n        if (!style.stroke) {\n            return origBBox;\n        }\n        return origBBox.grownBy(style.stroke.width / 2);\n    }\n    applyTransformation(affineTransfm) {\n        this.contentBBox = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__[\"default\"].empty;\n        let isFirstPart = true;\n        // Update each part\n        this.parts = this.parts.map((part) => {\n            const newPath = part.path.transformedBy(affineTransfm);\n            const newBBox = this.bboxForPart(newPath.bbox, part.style);\n            if (isFirstPart) {\n                this.contentBBox = newBBox;\n                isFirstPart = false;\n            }\n            else {\n                this.contentBBox = this.contentBBox.union(newBBox);\n            }\n            return {\n                path: newPath,\n                bbox: newBBox,\n                startPoint: newPath.startPoint,\n                commands: newPath.parts,\n                style: part.style,\n            };\n        });\n    }\n    description(localization) {\n        return localization.stroke;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/Stroke.ts?");

/***/ }),

/***/ "../../src/components/UnknownSVGObject.ts":
/*!************************************************!*\
  !*** ../../src/components/UnknownSVGObject.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UnknownSVGObject)\n/* harmony export */ });\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _rendering_SVGRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../rendering/SVGRenderer */ \"../../src/rendering/SVGRenderer.ts\");\n/* harmony import */ var _AbstractComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractComponent */ \"../../src/components/AbstractComponent.ts\");\n\n\n\nclass UnknownSVGObject extends _AbstractComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    constructor(svgObject) {\n        super();\n        this.svgObject = svgObject;\n        this.contentBBox = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of(svgObject.getBoundingClientRect());\n    }\n    render(canvas, _visibleRect) {\n        if (!(canvas instanceof _rendering_SVGRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])) {\n            // Don't draw unrenderable objects if we can't\n            return;\n        }\n        canvas.drawSVGElem(this.svgObject);\n    }\n    intersects(lineSegment) {\n        return this.contentBBox.getEdges().some(edge => edge.intersection(lineSegment) !== null);\n    }\n    applyTransformation(_affineTransfm) {\n    }\n    description(localization) {\n        return localization.svgObject;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/UnknownSVGObject.ts?");

/***/ }),

/***/ "../../src/components/builders/ArrowBuilder.ts":
/*!*****************************************************!*\
  !*** ../../src/components/builders/ArrowBuilder.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ArrowBuilder),\n/* harmony export */   \"makeArrowBuilder\": () => (/* binding */ makeArrowBuilder)\n/* harmony export */ });\n/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry/Path */ \"../../src/geometry/Path.ts\");\n/* harmony import */ var _Stroke__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Stroke */ \"../../src/components/Stroke.ts\");\n\n\nconst makeArrowBuilder = (initialPoint, _viewport) => {\n    return new ArrowBuilder(initialPoint);\n};\nclass ArrowBuilder {\n    constructor(startPoint) {\n        this.startPoint = startPoint;\n        this.endPoint = startPoint;\n    }\n    getLineWidth() {\n        return Math.max(this.endPoint.width, this.startPoint.width);\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const startPoint = this.startPoint.pos;\n        const endPoint = this.endPoint.pos;\n        const toEnd = endPoint.minus(startPoint).normalized();\n        const arrowLength = endPoint.minus(startPoint).length();\n        // Ensure that the arrow tip is smaller than the arrow.\n        const arrowTipSize = Math.min(this.getLineWidth(), arrowLength / 2);\n        const startSize = this.startPoint.width / 2;\n        const endSize = this.endPoint.width / 2;\n        const arrowTipBase = endPoint.minus(toEnd.times(arrowTipSize));\n        // Scaled normal vectors.\n        const lineNormal = toEnd.orthog();\n        const scaledStartNormal = lineNormal.times(startSize);\n        const scaledBaseNormal = lineNormal.times(endSize);\n        const preview = new _Stroke__WEBPACK_IMPORTED_MODULE_1__[\"default\"]([\n            {\n                startPoint: arrowTipBase.minus(scaledBaseNormal),\n                commands: [\n                    // Stem\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: startPoint.minus(scaledStartNormal),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: startPoint.plus(scaledStartNormal),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: arrowTipBase.plus(scaledBaseNormal),\n                    },\n                    // Head\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: arrowTipBase.plus(lineNormal.times(arrowTipSize).plus(scaledBaseNormal))\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: endPoint.plus(toEnd.times(endSize)),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: arrowTipBase.plus(lineNormal.times(-arrowTipSize).minus(scaledBaseNormal)),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: arrowTipBase.minus(scaledBaseNormal),\n                    },\n                ],\n                style: {\n                    fill: this.startPoint.color,\n                }\n            }\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/builders/ArrowBuilder.ts?");

/***/ }),

/***/ "../../src/components/builders/FreehandLineBuilder.ts":
/*!************************************************************!*\
  !*** ../../src/components/builders/FreehandLineBuilder.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ FreehandLineBuilder),\n/* harmony export */   \"makeFreehandLineBuilder\": () => (/* binding */ makeFreehandLineBuilder)\n/* harmony export */ });\n/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bezier-js */ \"../../node_modules/bezier-js/src/bezier.js\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geometry/Path */ \"../../src/geometry/Path.ts\");\n/* harmony import */ var _geometry_LineSegment2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geometry/LineSegment2 */ \"../../src/geometry/LineSegment2.ts\");\n/* harmony import */ var _Stroke__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Stroke */ \"../../src/components/Stroke.ts\");\n/* harmony import */ var _Viewport__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Viewport */ \"../../src/Viewport.ts\");\n\n\n\n\n\n\n\nconst makeFreehandLineBuilder = (initialPoint, viewport) => {\n    // Don't smooth if input is more than  7 pixels from the true curve, do smooth if\n    // less than  2 px from the curve.\n    const canvasTransform = viewport.screenToCanvasTransform;\n    const maxSmoothingDist = canvasTransform.transformVec3(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.unitX).magnitude() * 7;\n    const minSmoothingDist = canvasTransform.transformVec3(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.unitX).magnitude() * 2;\n    return new FreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist);\n};\n// Handles stroke smoothing and creates Strokes from user/stylus input.\nclass FreehandLineBuilder {\n    constructor(startPoint, \n    // Maximum distance from the actual curve (irrespective of stroke width)\n    // for which a point is considered 'part of the curve'.\n    // Note that the maximum will be smaller if the stroke width is less than\n    // [maxFitAllowed].\n    minFitAllowed, maxFitAllowed) {\n        this.startPoint = startPoint;\n        this.minFitAllowed = minFitAllowed;\n        this.maxFitAllowed = maxFitAllowed;\n        this.currentCurve = null;\n        this.lastPoint = this.startPoint;\n        this.segments = [];\n        this.buffer = [this.startPoint.pos];\n        this.momentum = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.zero;\n        this.currentCurve = null;\n        this.bbox = new _geometry_Rect2__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    getRenderingStyle() {\n        var _a;\n        return {\n            fill: (_a = this.lastPoint.color) !== null && _a !== void 0 ? _a : null,\n        };\n    }\n    // Get the segments that make up this' path. Can be called after calling build()\n    getPreview() {\n        if (this.currentCurve && this.lastPoint) {\n            const currentPath = this.currentSegmentToPath();\n            return this.segments.concat(currentPath);\n        }\n        return this.segments;\n    }\n    preview(renderer) {\n        for (const part of this.getPreview()) {\n            renderer.drawPath(part);\n        }\n    }\n    build() {\n        if (this.lastPoint) {\n            this.finalizeCurrentCurve();\n        }\n        return new _Stroke__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.segments);\n    }\n    roundPoint(point) {\n        return _Viewport__WEBPACK_IMPORTED_MODULE_6__[\"default\"].roundPoint(point, this.minFitAllowed);\n    }\n    finalizeCurrentCurve() {\n        // Case where no points have been added\n        if (!this.currentCurve) {\n            // Don't create a circle around the initial point if the stroke has more than one point.\n            if (this.segments.length > 0) {\n                return;\n            }\n            const width = _Viewport__WEBPACK_IMPORTED_MODULE_6__[\"default\"].roundPoint(this.startPoint.width / 3, this.minFitAllowed);\n            const center = this.roundPoint(this.startPoint.pos);\n            // Draw a circle-ish shape around the start point\n            this.segments.push({\n                // Start on the right, cycle clockwise:\n                //    |\n                //  ----- \n                //    |\n                startPoint: this.startPoint.pos.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(width, 0)),\n                commands: [\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_3__.PathCommandType.QuadraticBezierTo,\n                        controlPoint: center.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(width, width)),\n                        // Bottom of the circle\n                        //    |\n                        //  -----\n                        //    |\n                        //    \n                        endPoint: center.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0, width)),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_3__.PathCommandType.QuadraticBezierTo,\n                        controlPoint: center.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(-width, width)),\n                        endPoint: center.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(-width, 0)),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_3__.PathCommandType.QuadraticBezierTo,\n                        controlPoint: center.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(-width, -width)),\n                        endPoint: center.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0, -width)),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_3__.PathCommandType.QuadraticBezierTo,\n                        controlPoint: center.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(width, -width)),\n                        endPoint: center.plus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(width, 0)),\n                    },\n                ],\n                style: this.getRenderingStyle(),\n            });\n            return;\n        }\n        this.segments.push(this.currentSegmentToPath());\n        const lastPoint = this.buffer[this.buffer.length - 1];\n        this.lastExitingVec = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.points[2]).minus(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.points[1]));\n        console.assert(this.lastExitingVec.magnitude() !== 0);\n        // Use the last two points to start a new curve (the last point isn't used\n        // in the current curve and we want connected curves to share end points)\n        this.buffer = [\n            this.buffer[this.buffer.length - 2], lastPoint,\n        ];\n        this.currentCurve = null;\n    }\n    currentSegmentToPath() {\n        if (this.currentCurve == null) {\n            throw new Error('Invalid State: currentCurve is null!');\n        }\n        let startVec = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.normal(0)).normalized();\n        let endVec = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.normal(1)).normalized();\n        startVec = startVec.times(this.curveStartWidth / 2);\n        endVec = endVec.times(this.curveEndWidth / 2);\n        if (isNaN(startVec.magnitude())) {\n            // TODO: This can happen when events are too close together. Find out why and\n            // \t\t fix.\n            console.error('startVec is NaN', startVec, endVec, this.currentCurve);\n            startVec = endVec;\n        }\n        const startPt = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.get(0));\n        const endPt = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.get(1));\n        const controlPoint = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.points[1]);\n        // Approximate the normal at the location of the control point\n        let projectionT = this.currentCurve.project(controlPoint.xy).t;\n        if (!projectionT) {\n            if (startPt.minus(controlPoint).magnitudeSquared() < endPt.minus(controlPoint).magnitudeSquared()) {\n                projectionT = 0.1;\n            }\n            else {\n                projectionT = 0.9;\n            }\n        }\n        const halfVecT = projectionT;\n        let halfVec = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.normal(halfVecT))\n            .normalized().times(this.curveStartWidth / 2 * halfVecT\n            + this.curveEndWidth / 2 * (1 - halfVecT));\n        // Computes a boundary curve. [direction] should be either +1 or -1 (determines the side\n        // of the center curve to place the boundary).\n        const computeBoundaryCurve = (direction, halfVec) => {\n            return new bezier_js__WEBPACK_IMPORTED_MODULE_0__.Bezier(startPt.plus(startVec.times(direction)), controlPoint.plus(halfVec.times(direction)), endPt.plus(endVec.times(direction)));\n        };\n        const upperBoundary = computeBoundaryCurve(1, halfVec);\n        const lowerBoundary = computeBoundaryCurve(-1, halfVec);\n        // If the boundaries have two intersections, increasing the half vector's length could fix this.\n        if (upperBoundary.intersects(lowerBoundary).length === 2) {\n            halfVec = halfVec.times(2);\n        }\n        const pathCommands = [\n            {\n                kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_3__.PathCommandType.QuadraticBezierTo,\n                controlPoint: this.roundPoint(controlPoint.plus(halfVec)),\n                endPoint: this.roundPoint(endPt.plus(endVec)),\n            },\n            {\n                kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_3__.PathCommandType.LineTo,\n                point: this.roundPoint(endPt.minus(endVec)),\n            },\n            {\n                kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_3__.PathCommandType.QuadraticBezierTo,\n                controlPoint: this.roundPoint(controlPoint.minus(halfVec)),\n                endPoint: this.roundPoint(startPt.minus(startVec)),\n            },\n        ];\n        return {\n            startPoint: this.roundPoint(startPt.plus(startVec)),\n            commands: pathCommands,\n            style: this.getRenderingStyle(),\n        };\n    }\n    // Compute the direction of the velocity at the end of this.buffer\n    computeExitingVec() {\n        return this.momentum.normalized().times(this.lastPoint.width / 2);\n    }\n    addPoint(newPoint) {\n        var _a, _b;\n        if (this.lastPoint) {\n            // Ignore points that are identical\n            const fuzzEq = 1e-10;\n            const deltaTime = newPoint.time - this.lastPoint.time;\n            if (newPoint.pos.eq(this.lastPoint.pos, fuzzEq) || deltaTime === 0) {\n                console.warn('Discarding identical point');\n                return;\n            }\n            else if (isNaN(newPoint.pos.magnitude())) {\n                console.warn('Discarding NaN point.', newPoint);\n                return;\n            }\n            const threshold = Math.min(this.lastPoint.width, newPoint.width) / 4;\n            const shouldSnapToInitial = this.startPoint.pos.minus(newPoint.pos).magnitude() < threshold\n                && this.segments.length === 0;\n            // Snap to the starting point if the stroke is contained within a small ball centered\n            // at the starting point.\n            // This allows us to create a circle/dot at the start of the stroke.\n            if (shouldSnapToInitial) {\n                return;\n            }\n            const velocity = newPoint.pos.minus(this.lastPoint.pos).times(1 / (deltaTime) * 1000);\n            this.momentum = this.momentum.lerp(velocity, 0.9);\n        }\n        const lastPoint = (_a = this.lastPoint) !== null && _a !== void 0 ? _a : newPoint;\n        this.lastPoint = newPoint;\n        this.buffer.push(newPoint.pos);\n        const pointRadius = newPoint.width / 2;\n        const prevEndWidth = this.curveEndWidth;\n        this.curveEndWidth = pointRadius;\n        // recompute bbox\n        this.bbox = this.bbox.grownToPoint(newPoint.pos, pointRadius);\n        if (this.currentCurve === null) {\n            const p1 = lastPoint.pos;\n            const p2 = lastPoint.pos.plus((_b = this.lastExitingVec) !== null && _b !== void 0 ? _b : _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.unitX);\n            const p3 = newPoint.pos;\n            // Quadratic Bzier curve\n            this.currentCurve = new bezier_js__WEBPACK_IMPORTED_MODULE_0__.Bezier(p1.xy, p2.xy, p3.xy);\n            this.curveStartWidth = lastPoint.width / 2;\n            console.assert(!isNaN(p1.magnitude()) && !isNaN(p2.magnitude()) && !isNaN(p3.magnitude()), 'Expected !NaN');\n        }\n        let enteringVec = this.lastExitingVec;\n        if (!enteringVec) {\n            let sampleIdx = Math.ceil(this.buffer.length / 3);\n            if (sampleIdx === 0) {\n                sampleIdx = this.buffer.length - 1;\n            }\n            enteringVec = this.buffer[sampleIdx].minus(this.buffer[0]);\n        }\n        let exitingVec = this.computeExitingVec();\n        // Find the intersection between the entering vector and the exiting vector\n        const maxRelativeLength = 2;\n        const segmentStart = this.buffer[0];\n        const segmentEnd = newPoint.pos;\n        const startEndDist = segmentEnd.minus(segmentStart).magnitude();\n        const maxControlPointDist = maxRelativeLength * startEndDist;\n        // Exit in cases where we would divide by zero\n        if (maxControlPointDist === 0 || exitingVec.magnitude() === 0 || isNaN(exitingVec.magnitude())) {\n            return;\n        }\n        console.assert(!isNaN(enteringVec.magnitude()));\n        enteringVec = enteringVec.normalized();\n        exitingVec = exitingVec.normalized();\n        console.assert(!isNaN(enteringVec.magnitude()));\n        const lineFromStart = new _geometry_LineSegment2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](segmentStart, segmentStart.plus(enteringVec.times(maxControlPointDist)));\n        const lineFromEnd = new _geometry_LineSegment2__WEBPACK_IMPORTED_MODULE_4__[\"default\"](segmentEnd.minus(exitingVec.times(maxControlPointDist)), segmentEnd);\n        const intersection = lineFromEnd.intersection(lineFromStart);\n        // Position the control point at this intersection\n        let controlPoint;\n        if (intersection) {\n            controlPoint = intersection.point;\n        }\n        else {\n            // Position the control point closer to the first -- the connecting\n            // segment will be roughly a line.\n            controlPoint = segmentStart.plus(enteringVec.times(startEndDist / 4));\n        }\n        if (isNaN(controlPoint.magnitude()) || isNaN(segmentStart.magnitude())) {\n            console.error('controlPoint is NaN', intersection, 'Start:', segmentStart, 'End:', segmentEnd, 'in:', enteringVec, 'out:', exitingVec);\n        }\n        const prevCurve = this.currentCurve;\n        this.currentCurve = new bezier_js__WEBPACK_IMPORTED_MODULE_0__.Bezier(segmentStart.xy, controlPoint.xy, segmentEnd.xy);\n        if (isNaN(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(this.currentCurve.normal(0)).magnitude())) {\n            console.error('NaN normal at 0. Curve:', this.currentCurve);\n            this.currentCurve = prevCurve;\n        }\n        // Should we start making a new curve? Check whether all buffer points are within\n        // strokeWidth of the curve.\n        const curveMatchesPoints = (curve) => {\n            for (const point of this.buffer) {\n                const proj = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.ofXY(curve.project(point.xy));\n                const dist = proj.minus(point).magnitude();\n                const minFit = Math.max(Math.min(this.curveStartWidth, this.curveEndWidth) / 2, this.minFitAllowed);\n                if (dist > minFit || dist > this.maxFitAllowed) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        if (this.buffer.length > 3) {\n            if (!curveMatchesPoints(this.currentCurve)) {\n                // Use a curve that better fits the points\n                this.currentCurve = prevCurve;\n                this.curveEndWidth = prevEndWidth;\n                // Reset the last point -- the current point was not added to the curve.\n                this.lastPoint = lastPoint;\n                this.finalizeCurrentCurve();\n                return;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/builders/FreehandLineBuilder.ts?");

/***/ }),

/***/ "../../src/components/builders/LineBuilder.ts":
/*!****************************************************!*\
  !*** ../../src/components/builders/LineBuilder.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LineBuilder),\n/* harmony export */   \"makeLineBuilder\": () => (/* binding */ makeLineBuilder)\n/* harmony export */ });\n/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry/Path */ \"../../src/geometry/Path.ts\");\n/* harmony import */ var _Stroke__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Stroke */ \"../../src/components/Stroke.ts\");\n\n\nconst makeLineBuilder = (initialPoint, _viewport) => {\n    return new LineBuilder(initialPoint);\n};\nclass LineBuilder {\n    constructor(startPoint) {\n        this.startPoint = startPoint;\n        this.endPoint = startPoint;\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const startPoint = this.startPoint.pos;\n        const endPoint = this.endPoint.pos;\n        const toEnd = endPoint.minus(startPoint).normalized();\n        const startSize = this.startPoint.width / 2;\n        const endSize = this.endPoint.width / 2;\n        const lineNormal = toEnd.orthog();\n        const scaledStartNormal = lineNormal.times(startSize);\n        const scaledEndNormal = lineNormal.times(endSize);\n        const preview = new _Stroke__WEBPACK_IMPORTED_MODULE_1__[\"default\"]([\n            {\n                startPoint: startPoint.minus(scaledStartNormal),\n                commands: [\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: startPoint.plus(scaledStartNormal),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: endPoint.plus(scaledEndNormal),\n                    },\n                    {\n                        kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n                        point: endPoint.minus(scaledEndNormal),\n                    },\n                ],\n                style: {\n                    fill: this.startPoint.color,\n                }\n            }\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/builders/LineBuilder.ts?");

/***/ }),

/***/ "../../src/components/builders/RectangleBuilder.ts":
/*!*********************************************************!*\
  !*** ../../src/components/builders/RectangleBuilder.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RectangleBuilder),\n/* harmony export */   \"makeFilledRectangleBuilder\": () => (/* binding */ makeFilledRectangleBuilder),\n/* harmony export */   \"makeOutlinedRectangleBuilder\": () => (/* binding */ makeOutlinedRectangleBuilder)\n/* harmony export */ });\n/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../geometry/Path */ \"../../src/geometry/Path.ts\");\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _Stroke__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Stroke */ \"../../src/components/Stroke.ts\");\n\n\n\nconst makeFilledRectangleBuilder = (initialPoint, _viewport) => {\n    return new RectangleBuilder(initialPoint, true);\n};\nconst makeOutlinedRectangleBuilder = (initialPoint, _viewport) => {\n    return new RectangleBuilder(initialPoint, false);\n};\nclass RectangleBuilder {\n    constructor(startPoint, filled) {\n        this.startPoint = startPoint;\n        this.filled = filled;\n        // Initially, the start and end points are the same.\n        this.endPoint = startPoint;\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const startPoint = this.startPoint.pos;\n        const endPoint = this.endPoint.pos;\n        const path = _geometry_Path__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromRect(_geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromCorners(startPoint, endPoint), this.filled ? null : this.endPoint.width);\n        const preview = new _Stroke__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([\n            path.toRenderable({\n                fill: this.endPoint.color\n            }),\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/builders/RectangleBuilder.ts?");

/***/ }),

/***/ "../../src/components/localization.ts":
/*!********************************************!*\
  !*** ../../src/components/localization.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultComponentLocalization\": () => (/* binding */ defaultComponentLocalization)\n/* harmony export */ });\nconst defaultComponentLocalization = {\n    stroke: 'Stroke',\n    svgObject: 'SVG Object',\n};\n\n\n//# sourceURL=webpack://jsdraw/../../src/components/localization.ts?");

/***/ }),

/***/ "../../src/geometry/LineSegment2.ts":
/*!******************************************!*\
  !*** ../../src/geometry/LineSegment2.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LineSegment2)\n/* harmony export */ });\n/* harmony import */ var _Rect2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vec2 */ \"../../src/geometry/Vec2.ts\");\n\n\nclass LineSegment2 {\n    constructor(point1, point2) {\n        this.point1 = point1;\n        this.point2 = point2;\n        this.bbox = _Rect2__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bboxOf([point1, point2]);\n        this.direction = point2.minus(point1);\n        this.length = this.direction.magnitude();\n        // Normalize\n        if (this.length > 0) {\n            this.direction = this.direction.times(1 / this.length);\n        }\n    }\n    // Accessors to make LineSegment2 compatible with bezier-js's\n    // interface\n    get p1() {\n        return this.point1;\n    }\n    get p2() {\n        return this.point2;\n    }\n    get(t) {\n        return this.point1.plus(this.direction.times(t));\n    }\n    intersection(other) {\n        // We want x(t) = x(t) and y(t) = y(t)\n        // Observe that\n        // x = this.point1.x + this.direction.x  t\n        //   = other.point1.x + other.direction.x  t\n        // Thus,\n        //  t = (x - this.point1.x) / this.direction.x\n        //     = (y - this.point1.y) / this.direction.y\n        // and\n        //  t = (x - other.point1.x) / other.direction.x\n        // (and similarly for y)\n        //\n        // Letting o = this.point1.x, o = other.point1.x,\n        //         d = this.direction.y, ...\n        //\n        // We can substitute these into the equations for y:\n        // y = o + d  (x - o) / d\n        //   = o + d  (x - o) / d\n        //  o - o = d  (x - o) / d - d  (x - o) / d\n        //            = (d/d)(x) - (d/d)(o) - (d/d)(x) + (d/d)(o)\n        //            = (x)(d/d - d/d) - (d/d)(o) + (d/d)(o)\n        //  (x)(d/d - d/d) = o - o + (d/d)(o) - (d/d)(o)\n        //  x = (o - o + (d/d)(o) - (d/d)(o))/(d/d - d/d)\n        //     = (dd)(o - o + (d/d)(o) - (d/d)(o))/(dd - dd)\n        //     = ((o - o)((dd)) + (dd)(o) - (dd)(o))/(dd - dd)\n        //  y = o + d  (x - o) / d = ...\n        let resultPoint, resultT;\n        if (this.direction.x === 0) {\n            // Vertical line: Where does the other have x = this.point1.x?\n            // x = o = o + d  (y - o) / d\n            //  (o - o)(d/d) + o = y\n            // Avoid division by zero\n            if (other.direction.x === 0 || this.direction.y === 0) {\n                return null;\n            }\n            const xIntersect = this.point1.x;\n            const yIntersect = (this.point1.x - other.point1.x) * other.direction.y / other.direction.x + other.point1.y;\n            resultPoint = _Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(xIntersect, yIntersect);\n            resultT = (yIntersect - this.point1.y) / this.direction.y;\n        }\n        else {\n            // From above,\n            // x = ((o - o)(dd) + (dd)(o) - (dd)(o))/(dd - dd)\n            const numerator = ((this.point1.y - other.point1.y) * this.direction.x * other.direction.x\n                + this.direction.x * other.direction.y * other.point1.x\n                - this.direction.y * other.direction.x * this.point1.x);\n            const denominator = (other.direction.y * this.direction.x\n                - this.direction.y * other.direction.x);\n            // Avoid dividing by zero. It means there is no intersection\n            if (denominator === 0) {\n                return null;\n            }\n            const xIntersect = numerator / denominator;\n            const t1 = (xIntersect - this.point1.x) / this.direction.x;\n            const yIntersect = this.point1.y + this.direction.y * t1;\n            resultPoint = _Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(xIntersect, yIntersect);\n            resultT = (xIntersect - this.point1.x) / this.direction.x;\n        }\n        // Ensure the result is in this/the other segment.\n        const resultToP1 = resultPoint.minus(this.point1).magnitude();\n        const resultToP2 = resultPoint.minus(this.point2).magnitude();\n        const resultToP3 = resultPoint.minus(other.point1).magnitude();\n        const resultToP4 = resultPoint.minus(other.point2).magnitude();\n        if (resultToP1 > this.length\n            || resultToP2 > this.length\n            || resultToP3 > other.length\n            || resultToP4 > other.length) {\n            return null;\n        }\n        return {\n            point: resultPoint,\n            t: resultT,\n        };\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/geometry/LineSegment2.ts?");

/***/ }),

/***/ "../../src/geometry/Mat33.ts":
/*!***********************************!*\
  !*** ../../src/geometry/Mat33.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mat33)\n/* harmony export */ });\n/* harmony import */ var _Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _Vec3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vec3 */ \"../../src/geometry/Vec3.ts\");\n\n\n// Represents a three dimensional linear transformation or\n// a two-dimensional affine transformation. (An affine transformation scales/rotates/shears\n// **and** translates while a linear transformation just scales/rotates/shears).\nclass Mat33 {\n    constructor(a1, a2, a3, b1, b2, b3, c1, c2, c3) {\n        this.a1 = a1;\n        this.a2 = a2;\n        this.a3 = a3;\n        this.b1 = b1;\n        this.b2 = b2;\n        this.b3 = b3;\n        this.c1 = c1;\n        this.c2 = c2;\n        this.c3 = c3;\n        this.cachedInverse = undefined;\n        this.rows = [\n            _Vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"].of(a1, a2, a3),\n            _Vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"].of(b1, b2, b3),\n            _Vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"].of(c1, c2, c3),\n        ];\n    }\n    static ofRows(r1, r2, r3) {\n        return new Mat33(r1.x, r1.y, r1.z, r2.x, r2.y, r2.z, r3.x, r3.y, r3.z);\n    }\n    // Either returns the inverse of this, or, if this matrix is singular/uninvertable,\n    // returns Mat33.identity.\n    inverse() {\n        var _a;\n        return (_a = this.computeInverse()) !== null && _a !== void 0 ? _a : Mat33.identity;\n    }\n    invertable() {\n        return this.computeInverse() !== null;\n    }\n    computeInverse() {\n        if (this.cachedInverse !== undefined) {\n            return this.cachedInverse;\n        }\n        const toIdentity = [\n            this.rows[0],\n            this.rows[1],\n            this.rows[2],\n        ];\n        const toResult = [\n            _Vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"].unitX,\n            _Vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"].unitY,\n            _Vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"].unitZ,\n        ];\n        // Convert toIdentity to the identity matrix and\n        // toResult to the inverse through elementary row operations\n        for (let cursor = 0; cursor < 3; cursor++) {\n            // Select the [cursor]th diagonal entry\n            let pivot = toIdentity[cursor].at(cursor);\n            // Don't divide by zero (treat very small numbers as zero).\n            const minDivideBy = 1e-10;\n            if (Math.abs(pivot) < minDivideBy) {\n                let swapIndex = -1;\n                // For all other rows,\n                for (let i = 1; i <= 2; i++) {\n                    const otherRowIdx = (cursor + i) % 3;\n                    if (Math.abs(toIdentity[otherRowIdx].at(cursor)) >= minDivideBy) {\n                        swapIndex = otherRowIdx;\n                        break;\n                    }\n                }\n                // Can't swap with another row?\n                if (swapIndex === -1) {\n                    this.cachedInverse = null;\n                    return null;\n                }\n                const tmpIdentityRow = toIdentity[cursor];\n                const tmpResultRow = toResult[cursor];\n                // Swap!\n                toIdentity[cursor] = toIdentity[swapIndex];\n                toResult[cursor] = toResult[swapIndex];\n                toIdentity[swapIndex] = tmpIdentityRow;\n                toResult[swapIndex] = tmpResultRow;\n                pivot = toIdentity[cursor].at(cursor);\n            }\n            // Make toIdentity[k = cursor] = 1\n            let scale = 1.0 / pivot;\n            toIdentity[cursor] = toIdentity[cursor].times(scale);\n            toResult[cursor] = toResult[cursor].times(scale);\n            const cursorToIdentityRow = toIdentity[cursor];\n            const cursorToResultRow = toResult[cursor];\n            // Make toIdentity[k  cursor] = 0\n            for (let i = 1; i <= 2; i++) {\n                const otherRowIdx = (cursor + i) % 3;\n                scale = -toIdentity[otherRowIdx].at(cursor);\n                toIdentity[otherRowIdx] = toIdentity[otherRowIdx].plus(cursorToIdentityRow.times(scale));\n                toResult[otherRowIdx] = toResult[otherRowIdx].plus(cursorToResultRow.times(scale));\n            }\n        }\n        const inverse = Mat33.ofRows(toResult[0], toResult[1], toResult[2]);\n        this.cachedInverse = inverse;\n        return inverse;\n    }\n    transposed() {\n        return new Mat33(this.a1, this.b1, this.c1, this.a2, this.b2, this.c2, this.a3, this.b3, this.c3);\n    }\n    rightMul(other) {\n        other = other.transposed();\n        const at = (row, col) => {\n            return this.rows[row].dot(other.rows[col]);\n        };\n        return new Mat33(at(0, 0), at(0, 1), at(0, 2), at(1, 0), at(1, 1), at(1, 2), at(2, 0), at(2, 1), at(2, 2));\n    }\n    // Applies this as an affine transformation to the given vector.\n    // Returns a transformed version of [other].\n    transformVec2(other) {\n        // When transforming a Vec2, we want to use the z transformation\n        // components of this for translation:\n        //   . . tX \n        //   . . tY \n        //   0 0 1  \n        // For this, we need other's z component to be 1 (so that tX and tY\n        // are scaled by 1):\n        let intermediate = _Vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"].of(other.x, other.y, 1);\n        intermediate = this.transformVec3(intermediate);\n        // Drop the z=1 to allow magnitude to work as expected\n        return _Vec2__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(intermediate.x, intermediate.y);\n    }\n    // Applies this as a linear transformation to the given vector (doesn't translate).\n    // This is the standard way of transforming vectors in .\n    transformVec3(other) {\n        return _Vec3__WEBPACK_IMPORTED_MODULE_1__[\"default\"].of(this.rows[0].dot(other), this.rows[1].dot(other), this.rows[2].dot(other));\n    }\n    // Returns true iff this = other  fuzz\n    eq(other, fuzz = 0) {\n        for (let i = 0; i < 3; i++) {\n            if (!this.rows[i].eq(other.rows[i], fuzz)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        return `\n ${this.a1},\\t ${this.a2},\\t ${this.a3}\\t \n ${this.b1},\\t ${this.b2},\\t ${this.b3}\\t \n ${this.c1},\\t ${this.c2},\\t ${this.c3}\\t \n\t\t`.trimRight();\n    }\n    // result[0] = top left element\n    // result[1] = element at row zero, column 1\n    // ...\n    toArray() {\n        return [\n            this.a1, this.a2, this.a3,\n            this.b1, this.b2, this.b3,\n            this.c1, this.c2, this.c3,\n        ];\n    }\n    // Constructs a 3x3 translation matrix (for translating Vec2s)\n    static translation(amount) {\n        // When transforming Vec2s by a 3x3 matrix, we give the input\n        // Vec2s z = 1. As such,\n        //   outVec2.x = inVec2.x * 1 + inVec2.y * 0 + 1 * amount.x\n        //   ...\n        return new Mat33(1, 0, amount.x, 0, 1, amount.y, 0, 0, 1);\n    }\n    static zRotation(radians, center = _Vec2__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        // Translate everything so that rotation is about the origin\n        let result = Mat33.translation(center);\n        result = result.rightMul(new Mat33(cos, -sin, 0, sin, cos, 0, 0, 0, 1));\n        return result.rightMul(Mat33.translation(center.times(-1)));\n    }\n    static scaling2D(amount, center = _Vec2__WEBPACK_IMPORTED_MODULE_0__.Vec2.zero) {\n        let result = Mat33.translation(center);\n        let xAmount, yAmount;\n        if (typeof amount === 'number') {\n            xAmount = amount;\n            yAmount = amount;\n        }\n        else {\n            xAmount = amount.x;\n            yAmount = amount.y;\n        }\n        result = result.rightMul(new Mat33(xAmount, 0, 0, 0, yAmount, 0, 0, 0, 1));\n        // Translate such that [center] goes to (0, 0)\n        return result.rightMul(Mat33.translation(center.times(-1)));\n    }\n}\nMat33.identity = new Mat33(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n\n//# sourceURL=webpack://jsdraw/../../src/geometry/Mat33.ts?");

/***/ }),

/***/ "../../src/geometry/Path.ts":
/*!**********************************!*\
  !*** ../../src/geometry/Path.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PathCommandType\": () => (/* binding */ PathCommandType),\n/* harmony export */   \"default\": () => (/* binding */ Path)\n/* harmony export */ });\n/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bezier-js */ \"../../node_modules/bezier-js/src/bezier.js\");\n/* harmony import */ var _LineSegment2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LineSegment2 */ \"../../src/geometry/LineSegment2.ts\");\n/* harmony import */ var _Rect2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _Vec2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vec2 */ \"../../src/geometry/Vec2.ts\");\n\n\n\n\nvar PathCommandType;\n(function (PathCommandType) {\n    PathCommandType[PathCommandType[\"LineTo\"] = 0] = \"LineTo\";\n    PathCommandType[PathCommandType[\"MoveTo\"] = 1] = \"MoveTo\";\n    PathCommandType[PathCommandType[\"CubicBezierTo\"] = 2] = \"CubicBezierTo\";\n    PathCommandType[PathCommandType[\"QuadraticBezierTo\"] = 3] = \"QuadraticBezierTo\";\n})(PathCommandType || (PathCommandType = {}));\nclass Path {\n    constructor(startPoint, parts) {\n        this.startPoint = startPoint;\n        this.parts = parts;\n        this.cachedGeometry = null;\n        // Initial bounding box contains one point: the start point.\n        this.bbox = _Rect2__WEBPACK_IMPORTED_MODULE_2__[\"default\"].bboxOf([startPoint]);\n        // Convert into a representation of the geometry (cache for faster intersection\n        // calculation)\n        for (const part of parts) {\n            this.bbox = this.bbox.union(Path.computeBBoxForSegment(startPoint, part));\n        }\n    }\n    // Lazy-loads and returns this path's geometry\n    get geometry() {\n        if (this.cachedGeometry) {\n            return this.cachedGeometry;\n        }\n        let startPoint = this.startPoint;\n        const geometry = [];\n        for (const part of this.parts) {\n            switch (part.kind) {\n                case PathCommandType.CubicBezierTo:\n                    geometry.push(new bezier_js__WEBPACK_IMPORTED_MODULE_0__.Bezier(startPoint.xy, part.controlPoint1.xy, part.controlPoint2.xy, part.endPoint.xy));\n                    startPoint = part.endPoint;\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    geometry.push(new bezier_js__WEBPACK_IMPORTED_MODULE_0__.Bezier(startPoint.xy, part.controlPoint.xy, part.endPoint.xy));\n                    startPoint = part.endPoint;\n                    break;\n                case PathCommandType.LineTo:\n                    geometry.push(new _LineSegment2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](startPoint, part.point));\n                    startPoint = part.point;\n                    break;\n                case PathCommandType.MoveTo:\n                    startPoint = part.point;\n                    break;\n            }\n        }\n        this.cachedGeometry = geometry;\n        return this.cachedGeometry;\n    }\n    static computeBBoxForSegment(startPoint, part) {\n        const points = [startPoint];\n        let exhaustivenessCheck;\n        switch (part.kind) {\n            case PathCommandType.MoveTo:\n            case PathCommandType.LineTo:\n                points.push(part.point);\n                break;\n            case PathCommandType.CubicBezierTo:\n                points.push(part.controlPoint1, part.controlPoint2, part.endPoint);\n                break;\n            case PathCommandType.QuadraticBezierTo:\n                points.push(part.controlPoint, part.endPoint);\n                break;\n            default:\n                exhaustivenessCheck = part;\n                return exhaustivenessCheck;\n        }\n        return _Rect2__WEBPACK_IMPORTED_MODULE_2__[\"default\"].bboxOf(points);\n    }\n    intersection(line) {\n        const result = [];\n        for (const part of this.geometry) {\n            if (part instanceof _LineSegment2__WEBPACK_IMPORTED_MODULE_1__[\"default\"]) {\n                const intersection = part.intersection(line);\n                if (intersection) {\n                    result.push({\n                        curve: part,\n                        parameterValue: intersection.t,\n                        point: intersection.point,\n                    });\n                }\n            }\n            else {\n                const intersectionPoints = part.intersects(line).map(t => {\n                    // We're using the .intersects(line) function, which is documented\n                    // to always return numbers. However, to satisfy the type checker (and\n                    // possibly improperly-defined types),\n                    if (typeof t === 'string') {\n                        t = parseFloat(t);\n                    }\n                    const point = _Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.ofXY(part.get(t));\n                    // Ensure that the intersection is on the line\n                    if (point.minus(line.p1).magnitude() > line.length\n                        || point.minus(line.p2).magnitude() > line.length) {\n                        return null;\n                    }\n                    return {\n                        point,\n                        parameterValue: t,\n                        curve: part,\n                    };\n                }).filter(entry => entry !== null);\n                result.push(...intersectionPoints);\n            }\n        }\n        return result;\n    }\n    transformedBy(affineTransfm) {\n        const startPoint = affineTransfm.transformVec2(this.startPoint);\n        const newParts = [];\n        let exhaustivenessCheck;\n        for (const part of this.parts) {\n            switch (part.kind) {\n                case PathCommandType.MoveTo:\n                case PathCommandType.LineTo:\n                    newParts.push({\n                        kind: part.kind,\n                        point: affineTransfm.transformVec2(part.point),\n                    });\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    newParts.push({\n                        kind: part.kind,\n                        controlPoint1: affineTransfm.transformVec2(part.controlPoint1),\n                        controlPoint2: affineTransfm.transformVec2(part.controlPoint2),\n                        endPoint: affineTransfm.transformVec2(part.endPoint),\n                    });\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    newParts.push({\n                        kind: part.kind,\n                        controlPoint: affineTransfm.transformVec2(part.controlPoint),\n                        endPoint: affineTransfm.transformVec2(part.endPoint),\n                    });\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n        return new Path(startPoint, newParts);\n    }\n    // Creates a new path by joining [other] to the end of this path\n    union(other) {\n        if (!other) {\n            return this;\n        }\n        return new Path(this.startPoint, [\n            ...this.parts,\n            {\n                kind: PathCommandType.MoveTo,\n                point: other.startPoint,\n            },\n            ...other.parts,\n        ]);\n    }\n    // Returns a path that outlines [rect]. If [lineWidth] is not given, the resultant path is\n    // the outline of [rect]. Otherwise, the resultant path represents a line of width [lineWidth]\n    // that traces [rect].\n    static fromRect(rect, lineWidth = null) {\n        const commands = [];\n        let corners;\n        let startPoint;\n        if (lineWidth !== null) {\n            // Vector from the top left corner or bottom right corner to the edge of the\n            // stroked region.\n            const cornerToEdge = _Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(lineWidth, lineWidth).times(0.5);\n            const innerRect = _Rect2__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromCorners(rect.topLeft.plus(cornerToEdge), rect.bottomRight.minus(cornerToEdge));\n            const outerRect = _Rect2__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromCorners(rect.topLeft.minus(cornerToEdge), rect.bottomRight.plus(cornerToEdge));\n            corners = [\n                innerRect.corners[3],\n                ...innerRect.corners,\n                ...outerRect.corners.reverse(),\n            ];\n            startPoint = outerRect.corners[3];\n        }\n        else {\n            corners = rect.corners.slice(1);\n            startPoint = rect.corners[0];\n        }\n        for (const corner of corners) {\n            commands.push({\n                kind: PathCommandType.LineTo,\n                point: corner,\n            });\n        }\n        return new Path(startPoint, commands);\n    }\n    static fromRenderable(renderable) {\n        return new Path(renderable.startPoint, renderable.commands);\n    }\n    toRenderable(fill) {\n        return {\n            startPoint: this.startPoint,\n            style: fill,\n            commands: this.parts,\n        };\n    }\n    toString() {\n        return Path.toString(this.startPoint, this.parts);\n    }\n    static toString(startPoint, parts) {\n        const result = [];\n        const toRoundedString = (num) => {\n            // Try to remove rounding errors. If the number ends in at least three/four zeroes\n            // (or nines) just one or two digits, it's probably a rounding error.\n            const fixRoundingUpExp = /^([-]?\\d*\\.?\\d*[1-9.])0{4,}\\d$/;\n            const hasRoundingDownExp = /^([-]?)(\\d*)\\.(\\d*9{4,}\\d)$/;\n            let text = num.toString();\n            if (text.indexOf('.') === -1) {\n                return text;\n            }\n            const roundingDownMatch = hasRoundingDownExp.exec(text);\n            if (roundingDownMatch) {\n                const negativeSign = roundingDownMatch[1];\n                const lastDigit = parseInt(text.charAt(text.length - 1), 10);\n                const postDecimal = parseInt(roundingDownMatch[3], 10);\n                const preDecimal = parseInt(roundingDownMatch[2], 10);\n                let newPostDecimal = (postDecimal + 10 - lastDigit).toString();\n                let carry = 0;\n                if (newPostDecimal.length > postDecimal.toString().length) {\n                    // Left-shift\n                    newPostDecimal = newPostDecimal.substring(1);\n                    carry = 1;\n                }\n                text = `${negativeSign + (preDecimal + carry).toString()}.${newPostDecimal}`;\n            }\n            text = text.replace(fixRoundingUpExp, '$1');\n            // Remove trailing period (if it exists)\n            return text.replace(/[.]$/, '');\n        };\n        const addCommand = (command, ...points) => {\n            const parts = [];\n            for (const point of points) {\n                const xComponent = toRoundedString(point.x);\n                const yComponent = toRoundedString(point.y);\n                parts.push(`${xComponent},${yComponent}`);\n            }\n            result.push(`${command}${parts.join(' ')}`);\n        };\n        addCommand('M', startPoint);\n        let exhaustivenessCheck;\n        for (const part of parts) {\n            switch (part.kind) {\n                case PathCommandType.MoveTo:\n                    addCommand('M', part.point);\n                    break;\n                case PathCommandType.LineTo:\n                    addCommand('L', part.point);\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    addCommand('C', part.controlPoint1, part.controlPoint2, part.endPoint);\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    addCommand('Q', part.controlPoint, part.endPoint);\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n        return result.join('');\n    }\n    // Create a Path from a SVG path specification.\n    // TODO: Support a larger subset of SVG paths.\n    // TODO: Support s,t shorthands.\n    static fromString(pathString) {\n        // See the MDN reference:\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n        // and\n        // https://www.w3.org/TR/SVG2/paths.html\n        // Remove linebreaks\n        pathString = pathString.split('\\n').join(' ');\n        let lastPos = _Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.zero;\n        let firstPos = null;\n        let isFirstCommand = true;\n        const commands = [];\n        const moveTo = (point) => {\n            // The first moveTo/lineTo is already handled by the [startPoint] parameter of the Path constructor.\n            if (isFirstCommand) {\n                isFirstCommand = false;\n                return;\n            }\n            commands.push({\n                kind: PathCommandType.MoveTo,\n                point,\n            });\n        };\n        const lineTo = (point) => {\n            if (isFirstCommand) {\n                isFirstCommand = false;\n                return;\n            }\n            commands.push({\n                kind: PathCommandType.LineTo,\n                point,\n            });\n        };\n        const cubicBezierTo = (cp1, cp2, end) => {\n            commands.push({\n                kind: PathCommandType.CubicBezierTo,\n                controlPoint1: cp1,\n                controlPoint2: cp2,\n                endPoint: end,\n            });\n        };\n        const quadraticBeierTo = (controlPoint, endPoint) => {\n            commands.push({\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint,\n                endPoint,\n            });\n        };\n        // Each command: Command character followed by anything that isn't a command character\n        const commandExp = /([MmZzLlHhVvCcSsQqTtAa])\\s*([^a-zA-Z]*)/g;\n        let current;\n        while ((current = commandExp.exec(pathString)) !== null) {\n            const argParts = current[2].trim().split(/[^0-9.-]/).filter(part => part.length > 0);\n            const numericArgs = argParts.map(arg => parseFloat(arg));\n            const commandChar = current[1];\n            const uppercaseCommand = commandChar !== commandChar.toLowerCase();\n            const args = numericArgs.reduce((accumulator, current, index, parts) => {\n                if (index % 2 !== 0) {\n                    const currentAsFloat = current;\n                    const prevAsFloat = parts[index - 1];\n                    return accumulator.concat(_Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(prevAsFloat, currentAsFloat));\n                }\n                else {\n                    return accumulator;\n                }\n            }, []).map((coordinate) => {\n                // Lowercase commands are relative, uppercase commands use absolute\n                // positioning\n                if (uppercaseCommand) {\n                    lastPos = coordinate;\n                    return coordinate;\n                }\n                else {\n                    lastPos = lastPos.plus(coordinate);\n                    return lastPos;\n                }\n            });\n            let expectedPointArgCount;\n            switch (commandChar.toLowerCase()) {\n                case 'm':\n                    expectedPointArgCount = 1;\n                    moveTo(args[0]);\n                    break;\n                case 'l':\n                    expectedPointArgCount = 1;\n                    lineTo(args[0]);\n                    break;\n                case 'z':\n                    expectedPointArgCount = 0;\n                    // firstPos can be null if the stroke data is just 'z'.\n                    if (firstPos) {\n                        lineTo(firstPos);\n                    }\n                    break;\n                case 'c':\n                    expectedPointArgCount = 3;\n                    cubicBezierTo(args[0], args[1], args[2]);\n                    break;\n                case 'q':\n                    expectedPointArgCount = 2;\n                    quadraticBeierTo(args[0], args[1]);\n                    break;\n                // Horizontal line\n                case 'h':\n                    expectedPointArgCount = 0;\n                    if (uppercaseCommand) {\n                        lineTo(_Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(numericArgs[0], lastPos.y));\n                    }\n                    else {\n                        lineTo(lastPos.plus(_Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(numericArgs[0], 0)));\n                    }\n                    break;\n                // Vertical line\n                case 'v':\n                    expectedPointArgCount = 0;\n                    if (uppercaseCommand) {\n                        lineTo(_Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(lastPos.x, numericArgs[1]));\n                    }\n                    else {\n                        lineTo(lastPos.plus(_Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.of(0, numericArgs[1])));\n                    }\n                    break;\n                default:\n                    throw new Error(`Unknown path command ${commandChar}`);\n            }\n            if (args.length !== expectedPointArgCount) {\n                throw new Error(`\n\t\t\t\t\tIncorrect number of arguments: got ${JSON.stringify(args)} with a length of ${args.length}  ${expectedPointArgCount}.\n\t\t\t\t`.trim());\n            }\n            if (args.length > 0) {\n                firstPos !== null && firstPos !== void 0 ? firstPos : (firstPos = args[0]);\n            }\n            isFirstCommand = false;\n        }\n        return new Path(firstPos !== null && firstPos !== void 0 ? firstPos : _Vec2__WEBPACK_IMPORTED_MODULE_3__.Vec2.zero, commands);\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/geometry/Path.ts?");

/***/ }),

/***/ "../../src/geometry/Rect2.ts":
/*!***********************************!*\
  !*** ../../src/geometry/Rect2.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Rect2)\n/* harmony export */ });\n/* harmony import */ var _LineSegment2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineSegment2 */ \"../../src/geometry/LineSegment2.ts\");\n/* harmony import */ var _Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vec2 */ \"../../src/geometry/Vec2.ts\");\n\n\n// invariant: w > 0, h > 0.\nclass Rect2 {\n    constructor(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        if (w < 0) {\n            this.x += w;\n            this.w = Math.abs(w);\n        }\n        if (h < 0) {\n            this.y += h;\n            this.h = Math.abs(h);\n        }\n        // Precompute/store vector forms.\n        this.topLeft = _Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(this.x, this.y);\n        this.size = _Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(this.w, this.h);\n        this.bottomRight = this.topLeft.plus(this.size);\n        this.center = this.topLeft.plus(this.size.times(0.5));\n        this.area = this.w * this.h;\n    }\n    translatedBy(vec) {\n        return new Rect2(vec.x + this.x, vec.y + this.y, this.w, this.h);\n    }\n    resizedTo(size) {\n        return new Rect2(this.x, this.y, size.x, size.y);\n    }\n    containsPoint(other) {\n        return this.x <= other.x && this.y <= other.y\n            && this.x + this.w >= other.x && this.y + this.h >= other.y;\n    }\n    containsRect(other) {\n        return this.x <= other.x && this.y <= other.y\n            && this.bottomRight.x >= other.bottomRight.x\n            && this.bottomRight.y >= other.bottomRight.y;\n    }\n    intersects(other) {\n        return this.intersection(other) !== null;\n    }\n    // Returns the overlap of this and [other], or null, if no such\n    // /         overlap exists\n    intersection(other) {\n        const topLeft = this.topLeft.zip(other.topLeft, Math.max);\n        const bottomRight = this.bottomRight.zip(other.bottomRight, Math.min);\n        // The intersection can't be outside of this rectangle\n        if (!this.containsPoint(topLeft) || !this.containsPoint(bottomRight)) {\n            return null;\n        }\n        else if (!other.containsPoint(topLeft) || !other.containsPoint(bottomRight)) {\n            return null;\n        }\n        return Rect2.fromCorners(topLeft, bottomRight);\n    }\n    // Returns a new rectangle containing both [this] and [other].\n    union(other) {\n        const topLeft = this.topLeft.zip(other.topLeft, Math.min);\n        const bottomRight = this.bottomRight.zip(other.bottomRight, Math.max);\n        return Rect2.fromCorners(topLeft, bottomRight);\n    }\n    // Returns a rectangle containing this and [point].\n    // [margin] is the minimum distance between the new point and the edge\n    // of the resultant rectangle.\n    grownToPoint(point, margin = 0) {\n        const otherRect = new Rect2(point.x - margin, point.y - margin, margin * 2, margin * 2);\n        return this.union(otherRect);\n    }\n    // Returns this grown by [margin] in both the x and y directions.\n    grownBy(margin) {\n        return new Rect2(this.x - margin, this.y - margin, this.w + margin * 2, this.h + margin * 2);\n    }\n    get corners() {\n        return [\n            this.bottomRight,\n            this.topRight,\n            this.topLeft,\n            this.bottomLeft,\n        ];\n    }\n    get maxDimension() {\n        return Math.max(this.w, this.h);\n    }\n    get topRight() {\n        return this.bottomRight.plus(_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0, -this.h));\n    }\n    get bottomLeft() {\n        return this.topLeft.plus(_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0, this.h));\n    }\n    // Returns edges in the order\n    // [ rightEdge, topEdge, leftEdge, bottomEdge ]\n    getEdges() {\n        const corners = this.corners;\n        return [\n            new _LineSegment2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](corners[0], corners[1]),\n            new _LineSegment2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](corners[1], corners[2]),\n            new _LineSegment2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](corners[2], corners[3]),\n            new _LineSegment2__WEBPACK_IMPORTED_MODULE_0__[\"default\"](corners[3], corners[0]),\n        ];\n    }\n    // [affineTransform] is a transformation matrix that both scales and **translates**.\n    // the bounding box of this' four corners after transformed by the given affine transformation.\n    transformedBoundingBox(affineTransform) {\n        return Rect2.bboxOf(this.corners.map(corner => affineTransform.transformVec2(corner)));\n    }\n    /** @return true iff this is equal to [other]  fuzz */\n    eq(other, fuzz = 0) {\n        return this.topLeft.eq(other.topLeft, fuzz) && this.size.eq(other.size, fuzz);\n    }\n    toString() {\n        return `Rect(point(${this.x}, ${this.y}), size(${this.w}, ${this.h}))`;\n    }\n    static fromCorners(corner1, corner2) {\n        return new Rect2(Math.min(corner1.x, corner2.x), Math.min(corner1.y, corner2.y), Math.abs(corner1.x - corner2.x), Math.abs(corner1.y - corner2.y));\n    }\n    // Returns a box that contains all points in [points] with at least [margin]\n    // between each point and the edge of the box.\n    static bboxOf(points, margin = 0) {\n        let minX = 0;\n        let minY = 0;\n        let maxX = 0;\n        let maxY = 0;\n        let isFirst = true;\n        for (const point of points) {\n            if (isFirst) {\n                minX = point.x;\n                minY = point.y;\n                maxX = point.x;\n                maxY = point.y;\n                isFirst = false;\n            }\n            minX = Math.min(minX, point.x);\n            minY = Math.min(minY, point.y);\n            maxX = Math.max(maxX, point.x);\n            maxY = Math.max(maxY, point.y);\n        }\n        return Rect2.fromCorners(_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(minX - margin, minY - margin), _Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(maxX + margin, maxY + margin));\n    }\n    static of(template) {\n        var _a, _b, _c, _d;\n        const width = (_b = (_a = template.width) !== null && _a !== void 0 ? _a : template.w) !== null && _b !== void 0 ? _b : 0;\n        const height = (_d = (_c = template.height) !== null && _c !== void 0 ? _c : template.h) !== null && _d !== void 0 ? _d : 0;\n        return new Rect2(template.x, template.y, width, height);\n    }\n}\nRect2.empty = new Rect2(0, 0, 0, 0);\nRect2.unitSquare = new Rect2(0, 0, 1, 1);\n\n\n//# sourceURL=webpack://jsdraw/../../src/geometry/Rect2.ts?");

/***/ }),

/***/ "../../src/geometry/Vec2.ts":
/*!**********************************!*\
  !*** ../../src/geometry/Vec2.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vec2\": () => (/* binding */ Vec2)\n/* harmony export */ });\n/* harmony import */ var _Vec3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vec3 */ \"../../src/geometry/Vec3.ts\");\n\nvar Vec2;\n(function (Vec2) {\n    Vec2.of = (x, y) => {\n        return _Vec3__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of(x, y, 0);\n    };\n    Vec2.ofXY = ({ x, y }) => {\n        return _Vec3__WEBPACK_IMPORTED_MODULE_0__[\"default\"].of(x, y, 0);\n    };\n    Vec2.unitX = Vec2.of(1, 0);\n    Vec2.unitY = Vec2.of(0, 1);\n    Vec2.zero = Vec2.of(0, 0);\n})(Vec2 || (Vec2 = {}));\n\n\n//# sourceURL=webpack://jsdraw/../../src/geometry/Vec2.ts?");

/***/ }),

/***/ "../../src/geometry/Vec3.ts":
/*!**********************************!*\
  !*** ../../src/geometry/Vec3.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vec3)\n/* harmony export */ });\n// A vector with three components. Can also be used to represent a two-component vector\nclass Vec3 {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    // Returns the x, y components of this\n    get xy() {\n        // Useful for APIs that behave differently if .z is present.\n        return {\n            x: this.x,\n            y: this.y,\n        };\n    }\n    static of(x, y, z) {\n        return new Vec3(x, y, z);\n    }\n    // Returns this' [idx]th component\n    at(idx) {\n        if (idx === 0)\n            return this.x;\n        if (idx === 1)\n            return this.y;\n        if (idx === 2)\n            return this.z;\n        throw new Error(`${idx} out of bounds!`);\n    }\n    // Alias for this.magnitude\n    length() {\n        return this.magnitude();\n    }\n    magnitude() {\n        return Math.sqrt(this.dot(this));\n    }\n    magnitudeSquared() {\n        return this.dot(this);\n    }\n    // Return this' angle in the XY plane (treats this as a Vec2)\n    angle() {\n        return Math.atan2(this.y, this.x);\n    }\n    normalized() {\n        const norm = this.magnitude();\n        return Vec3.of(this.x / norm, this.y / norm, this.z / norm);\n    }\n    times(c) {\n        return Vec3.of(this.x * c, this.y * c, this.z * c);\n    }\n    plus(v) {\n        return Vec3.of(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    minus(v) {\n        return this.plus(v.times(-1));\n    }\n    dot(other) {\n        return this.x * other.x + this.y * other.y + this.z * other.z;\n    }\n    cross(other) {\n        // | i  j  k |\n        // | x1 y1 z1| = (i)(y1z2 - y2z1) - (j)(x1z2 - x2z1) + (k)(x1y2 - x2y1)\n        // | x2 y2 z2|\n        return Vec3.of(this.y * other.z - other.y * this.z, other.x * this.z - this.x * other.z, this.x * other.y - other.x * this.y);\n    }\n    // Returns a vector orthogonal to this. If this is a Vec2, returns [this] rotated\n    // 90 degrees counter-clockwise.\n    orthog() {\n        // If parallel to the z-axis\n        if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {\n            return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();\n        }\n        return this.cross(Vec3.unitZ.times(-1)).normalized();\n    }\n    // Returns this plus a vector of length [distance] in [direction]\n    extend(distance, direction) {\n        return this.plus(direction.normalized().times(distance));\n    }\n    // Returns a vector [fractionTo] of the way to target from this.\n    lerp(target, fractionTo) {\n        return this.times(1 - fractionTo).plus(target.times(fractionTo));\n    }\n    // [zip] Maps a component of this and a corresponding component of\n    // [other] to a component of the output vector.\n    zip(other, zip) {\n        return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, this.z));\n    }\n    // Returns a vector with each component acted on by [fn]\n    map(fn) {\n        return Vec3.of(fn(this.x), fn(this.y), fn(this.z));\n    }\n    asArray() {\n        return [this.x, this.y, this.z];\n    }\n    // [fuzz] The maximum difference between two components for this and [other]\n    // to be considered equal.\n    eq(other, fuzz) {\n        for (let i = 0; i < 3; i++) {\n            if (Math.abs(other.at(i) - this.at(i)) > fuzz) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        return `Vec(${this.x}, ${this.y}, ${this.z})`;\n    }\n}\nVec3.unitX = Vec3.of(1, 0, 0);\nVec3.unitY = Vec3.of(0, 1, 0);\nVec3.unitZ = Vec3.of(0, 0, 1);\nVec3.zero = Vec3.of(0, 0, 0);\n\n\n//# sourceURL=webpack://jsdraw/../../src/geometry/Vec3.ts?");

/***/ }),

/***/ "../../src/localization.ts":
/*!*********************************!*\
  !*** ../../src/localization.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultEditorLocalization\": () => (/* binding */ defaultEditorLocalization)\n/* harmony export */ });\n/* harmony import */ var _commands_localization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commands/localization */ \"../../src/commands/localization.ts\");\n/* harmony import */ var _components_localization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/localization */ \"../../src/components/localization.ts\");\n/* harmony import */ var _toolbar_localization__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toolbar/localization */ \"../../src/toolbar/localization.ts\");\n/* harmony import */ var _tools_localization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tools/localization */ \"../../src/tools/localization.ts\");\n\n\n\n\nconst defaultEditorLocalization = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, _toolbar_localization__WEBPACK_IMPORTED_MODULE_2__.defaultToolbarLocalization), _tools_localization__WEBPACK_IMPORTED_MODULE_3__.defaultToolLocalization), _commands_localization__WEBPACK_IMPORTED_MODULE_0__.defaultCommandLocalization), _components_localization__WEBPACK_IMPORTED_MODULE_1__.defaultComponentLocalization), { loading: (percentage) => `Loading ${percentage}%...`, imageEditor: 'Image Editor', doneLoading: 'Done loading', undoAnnouncement: (commandDescription) => `Undid ${commandDescription}`, redoAnnouncement: (commandDescription) => `Redid ${commandDescription}` });\n\n\n//# sourceURL=webpack://jsdraw/../../src/localization.ts?");

/***/ }),

/***/ "../../src/rendering/AbstractRenderer.ts":
/*!***********************************************!*\
  !*** ../../src/rendering/AbstractRenderer.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AbstractRenderer)\n/* harmony export */ });\n/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Path */ \"../../src/geometry/Path.ts\");\n\nconst stylesEqual = (a, b) => {\n    var _a, _b, _c, _d, _e;\n    return a === b || (a.fill.eq(b.fill)\n        && ((_b = (_a = a.stroke) === null || _a === void 0 ? void 0 : _a.color) === null || _b === void 0 ? void 0 : _b.eq((_c = b.stroke) === null || _c === void 0 ? void 0 : _c.color))\n        && ((_d = a.stroke) === null || _d === void 0 ? void 0 : _d.width) === ((_e = b.stroke) === null || _e === void 0 ? void 0 : _e.width));\n};\nclass AbstractRenderer {\n    constructor(viewport) {\n        this.viewport = viewport;\n        this.objectLevel = 0;\n        this.currentPaths = null;\n    }\n    flushPath() {\n        if (!this.currentPaths) {\n            return;\n        }\n        let lastStyle = null;\n        for (const path of this.currentPaths) {\n            const { startPoint, commands, style } = path;\n            if (!lastStyle || !stylesEqual(lastStyle, style)) {\n                if (lastStyle) {\n                    this.endPath(lastStyle);\n                }\n                this.beginPath(startPoint);\n                lastStyle = style;\n            }\n            else {\n                this.moveTo(startPoint);\n            }\n            for (const command of commands) {\n                if (command.kind === _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo) {\n                    this.lineTo(command.point);\n                }\n                else if (command.kind === _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo) {\n                    this.moveTo(command.point);\n                }\n                else if (command.kind === _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.CubicBezierTo) {\n                    this.traceCubicBezierCurve(command.controlPoint1, command.controlPoint2, command.endPoint);\n                }\n                else if (command.kind === _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo) {\n                    this.traceQuadraticBezierCurve(command.controlPoint, command.endPoint);\n                }\n            }\n        }\n        if (lastStyle) {\n            this.endPath(lastStyle);\n        }\n    }\n    drawPath(path) {\n        // If we're being called outside of an object,\n        // we can't delay rendering\n        if (this.objectLevel === 0) {\n            this.currentPaths = [path];\n            this.flushPath();\n            this.currentPaths = null;\n        }\n        else {\n            // Otherwise, don't render paths all at once. This prevents faint lines between\n            // segments of the same stroke from being visible.\n            this.currentPaths.push(path);\n        }\n    }\n    // Draw a rectangle. Boundary lines have width [lineWidth] and are filled with [lineFill]\n    drawRect(rect, lineWidth, lineFill) {\n        const path = _geometry_Path__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromRect(rect, lineWidth);\n        this.drawPath(path.toRenderable(lineFill));\n    }\n    // Note the start/end of an object with the given bounding box.\n    startObject(_boundingBox) {\n        this.currentPaths = [];\n        this.objectLevel++;\n    }\n    endObject() {\n        // Render the paths all at once\n        this.flushPath();\n        this.currentPaths = null;\n        this.objectLevel--;\n        if (this.objectLevel < 0) {\n            throw new Error('More objects have ended than have been started (negative object nesting level)!');\n        }\n    }\n    getNestingLevel() {\n        return this.objectLevel;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/rendering/AbstractRenderer.ts?");

/***/ }),

/***/ "../../src/rendering/CanvasRenderer.ts":
/*!*********************************************!*\
  !*** ../../src/rendering/CanvasRenderer.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CanvasRenderer)\n/* harmony export */ });\n/* harmony import */ var _Color4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Color4 */ \"../../src/Color4.ts\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _AbstractRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractRenderer */ \"../../src/rendering/AbstractRenderer.ts\");\n\n\n\nconst minSquareCurveApproxDist = 25;\nclass CanvasRenderer extends _AbstractRenderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    constructor(ctx, viewport) {\n        super(viewport);\n        this.ctx = ctx;\n        this.ignoreObjectsAboveLevel = null;\n        this.ignoringObject = false;\n    }\n    displaySize() {\n        return _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(this.ctx.canvas.clientWidth, this.ctx.canvas.clientHeight);\n    }\n    clear() {\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    }\n    beginPath(startPoint) {\n        startPoint = this.viewport.canvasToScreen(startPoint);\n        this.ctx.beginPath();\n        this.ctx.moveTo(startPoint.x, startPoint.y);\n    }\n    endPath(style) {\n        this.ctx.fillStyle = style.fill.toHexString();\n        this.ctx.fill();\n        if (style.stroke) {\n            this.ctx.strokeStyle = style.stroke.color.toHexString();\n            this.ctx.lineWidth = this.viewport.getScaleFactor() * style.stroke.width;\n            this.ctx.stroke();\n        }\n        this.ctx.closePath();\n    }\n    lineTo(point) {\n        point = this.viewport.canvasToScreen(point);\n        this.ctx.lineTo(point.x, point.y);\n    }\n    moveTo(point) {\n        point = this.viewport.canvasToScreen(point);\n        this.ctx.moveTo(point.x, point.y);\n    }\n    traceCubicBezierCurve(p1, p2, p3) {\n        p1 = this.viewport.canvasToScreen(p1);\n        p2 = this.viewport.canvasToScreen(p2);\n        p3 = this.viewport.canvasToScreen(p3);\n        // Approximate the curve if small enough.\n        const delta1 = p2.minus(p1);\n        const delta2 = p3.minus(p2);\n        if (delta1.magnitudeSquared() < minSquareCurveApproxDist\n            && delta2.magnitudeSquared() < minSquareCurveApproxDist) {\n            this.ctx.lineTo(p3.x, p3.y);\n        }\n        else {\n            this.ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n        }\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        controlPoint = this.viewport.canvasToScreen(controlPoint);\n        endPoint = this.viewport.canvasToScreen(endPoint);\n        // Approximate the curve with a line if small enough\n        const delta = controlPoint.minus(endPoint);\n        if (delta.magnitudeSquared() < minSquareCurveApproxDist) {\n            this.ctx.lineTo(endPoint.x, endPoint.y);\n        }\n        else {\n            this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y);\n        }\n    }\n    drawPath(path) {\n        if (this.ignoringObject) {\n            return;\n        }\n        super.drawPath(path);\n    }\n    startObject(boundingBox) {\n        // Should we ignore all objects within this object's bbox?\n        const diagonal = this.viewport.canvasToScreenTransform.transformVec3(boundingBox.size);\n        const minRenderSize = 4;\n        if (Math.abs(diagonal.x) < minRenderSize && Math.abs(diagonal.y) < minRenderSize) {\n            this.ignoreObjectsAboveLevel = this.getNestingLevel();\n            this.ignoringObject = true;\n        }\n        super.startObject(boundingBox);\n    }\n    endObject() {\n        super.endObject();\n        // If exiting an object with a too-small-to-draw bounding box,\n        if (this.ignoreObjectsAboveLevel !== null && this.getNestingLevel() <= this.ignoreObjectsAboveLevel) {\n            this.ignoreObjectsAboveLevel = null;\n            this.ignoringObject = false;\n        }\n    }\n    drawPoints(...points) {\n        const pointRadius = 10;\n        for (let i = 0; i < points.length; i++) {\n            const point = this.viewport.canvasToScreen(points[i]);\n            this.ctx.beginPath();\n            this.ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);\n            this.ctx.fillStyle = _Color4__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ofRGBA(0.5 + Math.sin(i) / 2, 1.0, 0.5 + Math.cos(i * 0.2) / 4, 0.5).toHexString();\n            this.ctx.fill();\n            this.ctx.stroke();\n            this.ctx.closePath();\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillStyle = 'black';\n            this.ctx.fillText(`${i}`, point.x, point.y, pointRadius * 2);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/rendering/CanvasRenderer.ts?");

/***/ }),

/***/ "../../src/rendering/DummyRenderer.ts":
/*!********************************************!*\
  !*** ../../src/rendering/DummyRenderer.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DummyRenderer)\n/* harmony export */ });\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _AbstractRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractRenderer */ \"../../src/rendering/AbstractRenderer.ts\");\n// Renderer that outputs nothing. Useful for automated tests.\n\n\nclass DummyRenderer extends _AbstractRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    constructor(viewport) {\n        super(viewport);\n        // Variables that track the state of what's been rendered\n        this.clearedCount = 0;\n        this.renderedPathCount = 0;\n        this.lastFillStyle = null;\n        this.lastPoint = null;\n        this.objectNestingLevel = 0;\n        // List of points drawn since the last clear.\n        this.pointBuffer = [];\n    }\n    displaySize() {\n        // Return a dummy\n        return _geometry_Vec2__WEBPACK_IMPORTED_MODULE_0__.Vec2.of(640, 480);\n    }\n    clear() {\n        this.clearedCount++;\n        this.renderedPathCount = 0;\n        this.pointBuffer = [];\n        // Ensure all objects finished rendering\n        if (this.objectNestingLevel > 0) {\n            throw new Error(`Within an object while clearing! Nesting level: ${this.objectNestingLevel}`);\n        }\n    }\n    beginPath(startPoint) {\n        this.lastPoint = startPoint;\n        this.pointBuffer.push(startPoint);\n    }\n    endPath(style) {\n        this.renderedPathCount++;\n        this.lastFillStyle = style;\n    }\n    lineTo(point) {\n        this.lastPoint = point;\n        this.pointBuffer.push(point);\n    }\n    moveTo(point) {\n        this.lastPoint = point;\n        this.pointBuffer.push(point);\n    }\n    traceCubicBezierCurve(p1, p2, p3) {\n        this.lastPoint = p3;\n        this.pointBuffer.push(p1, p2, p3);\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        this.lastPoint = endPoint;\n        this.pointBuffer.push(controlPoint, endPoint);\n    }\n    drawPoints(..._points) {\n        // drawPoints is intended for debugging.\n        // As such, it is unlikely to be the target of automated tests.\n    }\n    startObject(boundingBox) {\n        super.startObject(boundingBox);\n        this.objectNestingLevel += 1;\n    }\n    endObject() {\n        super.endObject();\n        this.objectNestingLevel -= 1;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/rendering/DummyRenderer.ts?");

/***/ }),

/***/ "../../src/rendering/SVGRenderer.ts":
/*!******************************************!*\
  !*** ../../src/rendering/SVGRenderer.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SVGRenderer)\n/* harmony export */ });\n/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Path */ \"../../src/geometry/Path.ts\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _AbstractRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbstractRenderer */ \"../../src/rendering/AbstractRenderer.ts\");\n\n\n\nconst svgNameSpace = 'http://www.w3.org/2000/svg';\nclass SVGRenderer extends _AbstractRenderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    constructor(elem, viewport) {\n        super(viewport);\n        this.elem = elem;\n        this.overwrittenAttrs = {};\n        this.clear();\n    }\n    // Sets an attribute on the root SVG element.\n    setRootSVGAttribute(name, value) {\n        // Make the original value of the attribute restorable on clear\n        if (!(name in this.overwrittenAttrs)) {\n            this.overwrittenAttrs[name] = this.elem.getAttribute(name);\n        }\n        if (value !== null) {\n            this.elem.setAttribute(name, value);\n        }\n        else {\n            this.elem.removeAttribute(name);\n        }\n    }\n    displaySize() {\n        return _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(this.elem.clientWidth, this.elem.clientHeight);\n    }\n    clear() {\n        this.mainGroup = document.createElementNS(svgNameSpace, 'g');\n        // Restore all alltributes\n        for (const attrName in this.overwrittenAttrs) {\n            const value = this.overwrittenAttrs[attrName];\n            if (value) {\n                this.elem.setAttribute(attrName, value);\n            }\n            else {\n                this.elem.removeAttribute(attrName);\n            }\n        }\n        this.overwrittenAttrs = {};\n        // Remove all children\n        this.elem.replaceChildren(this.mainGroup);\n    }\n    beginPath(startPoint) {\n        var _a;\n        this.currentPath = [];\n        this.pathStart = this.viewport.canvasToScreen(startPoint);\n        (_a = this.lastPathStart) !== null && _a !== void 0 ? _a : (this.lastPathStart = this.pathStart);\n    }\n    endPath(style) {\n        var _a;\n        if (this.currentPath == null) {\n            throw new Error('No path exists to end! Make sure beginPath was called!');\n        }\n        // Try to extend the previous path, if possible\n        if (style.fill.eq((_a = this.lastPathStyle) === null || _a === void 0 ? void 0 : _a.fill) && this.lastPath != null) {\n            this.lastPath.push({\n                kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo,\n                point: this.pathStart,\n            }, ...this.currentPath);\n            this.pathStart = null;\n            this.currentPath = null;\n        }\n        else {\n            this.addPathToSVG();\n            this.lastPathStart = this.pathStart;\n            this.lastPathStyle = style;\n            this.lastPath = this.currentPath;\n            this.pathStart = null;\n            this.currentPath = null;\n        }\n    }\n    // Push [this.fullPath] to the SVG\n    addPathToSVG() {\n        if (!this.lastPathStyle || !this.lastPath) {\n            return;\n        }\n        const pathElem = document.createElementNS(svgNameSpace, 'path');\n        pathElem.setAttribute('d', _geometry_Path__WEBPACK_IMPORTED_MODULE_0__[\"default\"].toString(this.lastPathStart, this.lastPath));\n        const style = this.lastPathStyle;\n        pathElem.setAttribute('fill', style.fill.toHexString());\n        if (style.stroke) {\n            pathElem.setAttribute('stroke', style.stroke.color.toHexString());\n            pathElem.setAttribute('stroke-width', style.stroke.width.toString());\n        }\n        this.mainGroup.appendChild(pathElem);\n    }\n    startObject(boundingBox) {\n        super.startObject(boundingBox);\n        // Only accumulate a path within an object\n        this.lastPath = null;\n        this.lastPathStart = null;\n        this.lastPathStyle = null;\n    }\n    endObject() {\n        super.endObject();\n        // Don't extend paths across objects\n        this.addPathToSVG();\n    }\n    lineTo(point) {\n        point = this.viewport.canvasToScreen(point);\n        this.currentPath.push({\n            kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.LineTo,\n            point,\n        });\n    }\n    moveTo(point) {\n        point = this.viewport.canvasToScreen(point);\n        this.currentPath.push({\n            kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.MoveTo,\n            point,\n        });\n    }\n    traceCubicBezierCurve(controlPoint1, controlPoint2, endPoint) {\n        controlPoint1 = this.viewport.canvasToScreen(controlPoint1);\n        controlPoint2 = this.viewport.canvasToScreen(controlPoint2);\n        endPoint = this.viewport.canvasToScreen(endPoint);\n        this.currentPath.push({\n            kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.CubicBezierTo,\n            controlPoint1,\n            controlPoint2,\n            endPoint,\n        });\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        controlPoint = this.viewport.canvasToScreen(controlPoint);\n        endPoint = this.viewport.canvasToScreen(endPoint);\n        this.currentPath.push({\n            kind: _geometry_Path__WEBPACK_IMPORTED_MODULE_0__.PathCommandType.QuadraticBezierTo,\n            controlPoint,\n            endPoint,\n        });\n    }\n    drawPoints(...points) {\n        points.map(point => {\n            const elem = document.createElementNS(svgNameSpace, 'circle');\n            elem.setAttribute('cx', `${point.x}`);\n            elem.setAttribute('cy', `${point.y}`);\n            elem.setAttribute('r', '15');\n            this.mainGroup.appendChild(elem);\n        });\n    }\n    // Renders a copy of the given element.\n    drawSVGElem(elem) {\n        this.elem.appendChild(elem.cloneNode(true));\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/rendering/SVGRenderer.ts?");

/***/ }),

/***/ "../../src/toolbar/HTMLToolbar.ts":
/*!****************************************!*\
  !*** ../../src/toolbar/HTMLToolbar.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HTMLToolbar)\n/* harmony export */ });\n/* harmony import */ var _tools_ToolController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/ToolController */ \"../../src/tools/ToolController.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types */ \"../../src/types.ts\");\n/* harmony import */ var _melloware_coloris__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @melloware/coloris */ \"../../node_modules/@melloware/coloris/dist/esm/coloris.js\");\n/* harmony import */ var _Color4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Color4 */ \"../../src/Color4.ts\");\n/* harmony import */ var _tools_Pen__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/Pen */ \"../../src/tools/Pen.ts\");\n/* harmony import */ var _tools_Eraser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tools/Eraser */ \"../../src/tools/Eraser.ts\");\n/* harmony import */ var _tools_SelectionTool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/SelectionTool */ \"../../src/tools/SelectionTool.ts\");\n/* harmony import */ var _components_builders_FreehandLineBuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/builders/FreehandLineBuilder */ \"../../src/components/builders/FreehandLineBuilder.ts\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _rendering_SVGRenderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../rendering/SVGRenderer */ \"../../src/rendering/SVGRenderer.ts\");\n/* harmony import */ var _Viewport__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Viewport */ \"../../src/Viewport.ts\");\n/* harmony import */ var _EventDispatcher__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../EventDispatcher */ \"../../src/EventDispatcher.ts\");\n/* harmony import */ var _components_builders_ArrowBuilder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../components/builders/ArrowBuilder */ \"../../src/components/builders/ArrowBuilder.ts\");\n/* harmony import */ var _components_builders_LineBuilder__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../components/builders/LineBuilder */ \"../../src/components/builders/LineBuilder.ts\");\n/* harmony import */ var _components_builders_RectangleBuilder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../components/builders/RectangleBuilder */ \"../../src/components/builders/RectangleBuilder.ts\");\n/* harmony import */ var _localization__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./localization */ \"../../src/toolbar/localization.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst primaryForegroundFill = `\n\tstyle='fill: var(--primary-foreground-color);'\n`;\nconst primaryForegroundStrokeFill = `\n\tstyle='fill: var(--primary-foreground-color); stroke: var(--primary-foreground-color);'\n`;\nconst toolbarCSSPrefix = 'toolbar-';\nconst svgNamespace = 'http://www.w3.org/2000/svg';\nclass ToolbarWidget {\n    constructor(editor, targetTool, localizationTable) {\n        this.editor = editor;\n        this.targetTool = targetTool;\n        this.localizationTable = localizationTable;\n        this.icon = null;\n        this.container = document.createElement('div');\n        this.container.classList.add(`${toolbarCSSPrefix}toolContainer`);\n        this.dropdownContainer = document.createElement('div');\n        this.dropdownContainer.classList.add(`${toolbarCSSPrefix}dropdown`);\n        this.dropdownContainer.classList.add('hidden');\n        this.hasDropdown = false;\n        this.button = document.createElement('div');\n        this.button.classList.add(`${toolbarCSSPrefix}button`);\n        this.label = document.createElement('label');\n        this.button.setAttribute('role', 'button');\n        this.button.tabIndex = 0;\n        this.button.onclick = () => {\n            this.handleClick();\n        };\n        editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolEnabled, toolEvt => {\n            if (toolEvt.kind !== _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolEnabled) {\n                throw new Error('Incorrect event type! (Expected ToolEnabled)');\n            }\n            if (toolEvt.tool === targetTool) {\n                this.updateSelected(true);\n            }\n        });\n        editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolDisabled, toolEvt => {\n            if (toolEvt.kind !== _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolDisabled) {\n                throw new Error('Incorrect event type! (Expected ToolDisabled)');\n            }\n            if (toolEvt.tool === targetTool) {\n                this.updateSelected(false);\n                this.setDropdownVisible(false);\n            }\n        });\n    }\n    handleClick() {\n        if (this.hasDropdown) {\n            if (!this.targetTool.isEnabled()) {\n                this.targetTool.setEnabled(true);\n            }\n            else {\n                this.setDropdownVisible(!this.isDropdownVisible());\n            }\n        }\n        else {\n            this.targetTool.setEnabled(!this.targetTool.isEnabled());\n        }\n    }\n    // Adds this to [parent]. This can only be called once for each ToolbarWidget.\n    addTo(parent) {\n        this.label.innerText = this.getTitle();\n        this.icon = null;\n        this.updateIcon();\n        this.updateSelected(this.targetTool.isEnabled());\n        this.button.replaceChildren(this.icon, this.label);\n        this.container.appendChild(this.button);\n        this.hasDropdown = this.fillDropdown(this.dropdownContainer);\n        if (this.hasDropdown) {\n            this.dropdownIcon = this.createDropdownIcon();\n            this.button.appendChild(this.dropdownIcon);\n            this.container.appendChild(this.dropdownContainer);\n        }\n        this.setDropdownVisible(false);\n        parent.appendChild(this.container);\n    }\n    updateIcon() {\n        var _a;\n        const newIcon = this.createIcon();\n        (_a = this.icon) === null || _a === void 0 ? void 0 : _a.replaceWith(newIcon);\n        this.icon = newIcon;\n        this.icon.classList.add(`${toolbarCSSPrefix}icon`);\n    }\n    updateSelected(selected) {\n        const currentlySelected = this.container.classList.contains('selected');\n        if (currentlySelected === selected) {\n            return;\n        }\n        if (selected) {\n            this.container.classList.add('selected');\n            this.button.ariaSelected = 'true';\n        }\n        else {\n            this.container.classList.remove('selected');\n            this.button.ariaSelected = 'false';\n        }\n    }\n    setDropdownVisible(visible) {\n        const currentlyVisible = this.container.classList.contains('dropdownVisible');\n        if (currentlyVisible === visible) {\n            return;\n        }\n        if (visible) {\n            this.dropdownContainer.classList.remove('hidden');\n            this.container.classList.add('dropdownVisible');\n            this.editor.announceForAccessibility(this.localizationTable.dropdownShown(this.targetTool.description));\n        }\n        else {\n            this.dropdownContainer.classList.add('hidden');\n            this.container.classList.remove('dropdownVisible');\n            this.editor.announceForAccessibility(this.localizationTable.dropdownHidden(this.targetTool.description));\n        }\n    }\n    isDropdownVisible() {\n        return !this.dropdownContainer.classList.contains('hidden');\n    }\n    createDropdownIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<path\n\t\t\t\td='M5,10 L50,90 L95,10 Z'\n\t\t\t\t${primaryForegroundFill}\n\t\t\t/>\n\t\t</g>\n\t\t`;\n        icon.classList.add(`${toolbarCSSPrefix}showHideDropdownIcon`);\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n}\nclass EraserWidget extends ToolbarWidget {\n    getTitle() {\n        return this.localizationTable.eraser;\n    }\n    createIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        // Draw an eraser-like shape\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<rect x=10 y=50 width=80 height=30 rx=10 fill='pink' />\n\t\t\t<rect\n\t\t\t\tx=10 y=10 width=80 height=50\n\t\t\t\t${primaryForegroundFill}\n\t\t\t/>\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    fillDropdown(_dropdown) {\n        // No dropdown associated with the eraser\n        return false;\n    }\n}\nclass SelectionWidget extends ToolbarWidget {\n    constructor(editor, tool, localization) {\n        super(editor, tool, localization);\n        this.tool = tool;\n    }\n    getTitle() {\n        return this.localizationTable.select;\n    }\n    createIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        // Draw a cursor-like shape\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<rect x=10 y=10 width=70 height=70 fill='pink' stroke='black'/>\n\t\t\t<rect x=75 y=75 width=10 height=10 fill='white' stroke='black'/>\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    fillDropdown(dropdown) {\n        const container = document.createElement('div');\n        const resizeButton = document.createElement('button');\n        resizeButton.innerText = this.localizationTable.resizeImageToSelection;\n        resizeButton.disabled = true;\n        resizeButton.onclick = () => {\n            const selection = this.tool.getSelection();\n            this.editor.dispatch(this.editor.setImportExportRect(selection.region));\n        };\n        // Enable/disable actions based on whether items are selected\n        this.editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated, toolEvt => {\n            if (toolEvt.kind !== _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated) {\n                throw new Error('Invalid event type!');\n            }\n            if (toolEvt.tool === this.tool) {\n                const selection = this.tool.getSelection();\n                const hasSelection = selection && selection.region.area > 0;\n                resizeButton.disabled = !hasSelection;\n            }\n        });\n        container.replaceChildren(resizeButton);\n        dropdown.appendChild(container);\n        return true;\n    }\n}\nclass TouchDrawingWidget extends ToolbarWidget {\n    getTitle() {\n        return this.localizationTable.touchDrawing;\n    }\n    createIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        // Draw a cursor-like shape\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<path d='M11,-30 Q0,10 20,20 Q40,20 40,-30 Z' fill='blue' stroke='black'/>\n\t\t\t<path d='\n\t\t\t\tM0,90 L0,50 Q5,40 10,50\n\t\t\t\tL10,20 Q20,15 30,20\n\t\t\t\tL30,50 Q50,40 80,50\n\t\t\t\tL80,90 L10,90 Z'\n\t\t\t\t\n\t\t\t\t${primaryForegroundStrokeFill}\n\t\t\t/>\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '-10 -30 100 100');\n        return icon;\n    }\n    fillDropdown(_dropdown) {\n        // No dropdown\n        return false;\n    }\n    updateSelected(active) {\n        if (active) {\n            this.container.classList.remove('selected');\n        }\n        else {\n            this.container.classList.add('selected');\n        }\n    }\n}\nclass PenWidget extends ToolbarWidget {\n    constructor(editor, tool, localization, penTypes) {\n        super(editor, tool, localization);\n        this.tool = tool;\n        this.penTypes = penTypes;\n        this.updateInputs = () => { };\n        this.editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated, toolEvt => {\n            if (toolEvt.kind !== _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ToolUpdated) {\n                throw new Error('Invalid event type!');\n            }\n            // The button icon may depend on tool properties.\n            if (toolEvt.tool === this.tool) {\n                this.updateIcon();\n                this.updateInputs();\n            }\n        });\n    }\n    getTitle() {\n        return this.targetTool.description;\n    }\n    makePenIcon(elem) {\n        // Use a square-root scale to prevent the pen's tip from overflowing.\n        const scale = Math.round(Math.sqrt(this.tool.getThickness()) * 2);\n        const color = this.tool.getColor();\n        // Draw a pen-like shape\n        const primaryStrokeTipPath = `M14,63 L${50 - scale},95 L${50 + scale},90 L88,60 Z`;\n        const backgroundStrokeTipPath = `M14,63 L${50 - scale},85 L${50 + scale},83 L88,60 Z`;\n        elem.innerHTML = `\n\t\t<defs>\n\t\t\t<pattern\n\t\t\t\tid='checkerboard'\n\t\t\t\tviewBox='0,0,10,10'\n\t\t\t\twidth='20%'\n\t\t\t\theight='20%'\n\t\t\t\tpatternUnits='userSpaceOnUse'\n\t\t\t>\n\t\t\t\t<rect x=0 y=0 width=10 height=10 fill='white'/>\n\t\t\t\t<rect x=0 y=0 width=5 height=5 fill='gray'/>\n\t\t\t\t<rect x=5 y=5 width=5 height=5 fill='gray'/>\n\t\t\t</pattern>\n\t\t</defs>\n\t\t<g>\n\t\t\t<!-- Pen grip -->\n\t\t\t<path\n\t\t\t\td='M10,10 L90,10 L90,60 L${50 + scale},80 L${50 - scale},80 L10,60 Z'\n\t\t\t\t${primaryForegroundStrokeFill}\n\t\t\t/>\n\t\t</g>\n\t\t<g>\n\t\t\t<!-- Checkerboard background for slightly transparent pens -->\n\t\t\t<path d='${backgroundStrokeTipPath}' fill='url(#checkerboard)'/>\n\n\t\t\t<!-- Actual pen tip -->\n\t\t\t<path\n\t\t\t\td='${primaryStrokeTipPath}'\n\t\t\t\tfill='${color.toHexString()}'\n\t\t\t\tstroke='${color.toHexString()}'\n\t\t\t/>\n\t\t</g>\n\t\t`;\n    }\n    // Draws an icon with the pen.\n    makeDrawnIcon(icon) {\n        const strokeFactory = this.tool.getStrokeFactory();\n        const toolThickness = this.tool.getThickness();\n        const nowTime = (new Date()).getTime();\n        const startPoint = {\n            pos: _geometry_Vec2__WEBPACK_IMPORTED_MODULE_8__.Vec2.of(10, 10),\n            width: toolThickness / 5,\n            color: this.tool.getColor(),\n            time: nowTime - 100,\n        };\n        const endPoint = {\n            pos: _geometry_Vec2__WEBPACK_IMPORTED_MODULE_8__.Vec2.of(90, 90),\n            width: toolThickness / 5,\n            color: this.tool.getColor(),\n            time: nowTime,\n        };\n        const builder = strokeFactory(startPoint, this.editor.viewport);\n        builder.addPoint(endPoint);\n        const viewport = new _Viewport__WEBPACK_IMPORTED_MODULE_10__[\"default\"](new _EventDispatcher__WEBPACK_IMPORTED_MODULE_11__[\"default\"]());\n        viewport.updateScreenSize(_geometry_Vec2__WEBPACK_IMPORTED_MODULE_8__.Vec2.of(100, 100));\n        const renderer = new _rendering_SVGRenderer__WEBPACK_IMPORTED_MODULE_9__[\"default\"](icon, viewport);\n        builder.preview(renderer);\n    }\n    createIcon() {\n        // We need to use createElementNS to embed an SVG element in HTML.\n        // See http://zhangwenli.com/blog/2017/07/26/createelementns/\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        const strokeFactory = this.tool.getStrokeFactory();\n        if (strokeFactory === _components_builders_FreehandLineBuilder__WEBPACK_IMPORTED_MODULE_7__.makeFreehandLineBuilder) {\n            this.makePenIcon(icon);\n        }\n        else {\n            this.makeDrawnIcon(icon);\n        }\n        return icon;\n    }\n    fillDropdown(dropdown) {\n        const container = document.createElement('div');\n        const thicknessRow = document.createElement('div');\n        const objectTypeRow = document.createElement('div');\n        // Thickness: Value of the input is squared to allow for finer control/larger values.\n        const thicknessLabel = document.createElement('label');\n        const thicknessInput = document.createElement('input');\n        const objectSelectLabel = document.createElement('label');\n        const objectTypeSelect = document.createElement('select');\n        // Give inputs IDs so we can label them with a <label for=...>Label text</label>\n        thicknessInput.id = `${toolbarCSSPrefix}thicknessInput${PenWidget.idCounter++}`;\n        objectTypeSelect.id = `${toolbarCSSPrefix}builderSelect${PenWidget.idCounter++}`;\n        thicknessLabel.innerText = this.localizationTable.thicknessLabel;\n        thicknessLabel.setAttribute('for', thicknessInput.id);\n        objectSelectLabel.innerText = this.localizationTable.selectObjectType;\n        objectSelectLabel.setAttribute('for', objectTypeSelect.id);\n        thicknessInput.type = 'range';\n        thicknessInput.min = '1';\n        thicknessInput.max = '20';\n        thicknessInput.step = '1';\n        thicknessInput.oninput = () => {\n            this.tool.setThickness(Math.pow(parseFloat(thicknessInput.value), 2));\n        };\n        thicknessRow.appendChild(thicknessLabel);\n        thicknessRow.appendChild(thicknessInput);\n        objectTypeSelect.oninput = () => {\n            const penTypeIdx = parseInt(objectTypeSelect.value);\n            if (penTypeIdx < 0 || penTypeIdx >= this.penTypes.length) {\n                console.error('Invalid pen type index', penTypeIdx);\n                return;\n            }\n            this.tool.setStrokeFactory(this.penTypes[penTypeIdx].factory);\n        };\n        objectTypeRow.appendChild(objectSelectLabel);\n        objectTypeRow.appendChild(objectTypeSelect);\n        const colorRow = document.createElement('div');\n        const colorLabel = document.createElement('label');\n        const colorInput = document.createElement('input');\n        colorInput.id = `${toolbarCSSPrefix}colorInput${PenWidget.idCounter++}`;\n        colorLabel.innerText = this.localizationTable.colorLabel;\n        colorLabel.setAttribute('for', colorInput.id);\n        colorInput.className = 'coloris_input';\n        colorInput.type = 'button';\n        colorInput.oninput = () => {\n            this.tool.setColor(_Color4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromHex(colorInput.value));\n        };\n        colorInput.addEventListener('open', () => {\n            this.editor.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ColorPickerToggled, {\n                kind: _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ColorPickerToggled,\n                open: true,\n            });\n        });\n        colorInput.addEventListener('close', () => {\n            this.editor.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ColorPickerToggled, {\n                kind: _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ColorPickerToggled,\n                open: false,\n            });\n        });\n        colorRow.appendChild(colorLabel);\n        colorRow.appendChild(colorInput);\n        this.updateInputs = () => {\n            colorInput.value = this.tool.getColor().toHexString();\n            thicknessInput.value = Math.sqrt(this.tool.getThickness()).toString();\n            objectTypeSelect.replaceChildren();\n            for (let i = 0; i < this.penTypes.length; i++) {\n                const penType = this.penTypes[i];\n                const option = document.createElement('option');\n                option.value = i.toString();\n                option.innerText = penType.name;\n                objectTypeSelect.appendChild(option);\n                if (penType.factory === this.tool.getStrokeFactory()) {\n                    objectTypeSelect.value = i.toString();\n                }\n            }\n        };\n        this.updateInputs();\n        container.replaceChildren(colorRow, thicknessRow, objectTypeRow);\n        dropdown.replaceChildren(container);\n        return true;\n    }\n}\nPenWidget.idCounter = 0;\nclass HTMLToolbar {\n    constructor(editor, parent, localizationTable = _localization__WEBPACK_IMPORTED_MODULE_15__.defaultToolbarLocalization) {\n        this.editor = editor;\n        this.localizationTable = localizationTable;\n        this.container = document.createElement('div');\n        this.container.classList.add(`${toolbarCSSPrefix}root`);\n        this.container.setAttribute('role', 'toolbar');\n        parent.appendChild(this.container);\n        (0,_melloware_coloris__WEBPACK_IMPORTED_MODULE_2__.init)();\n        this.setupColorPickers();\n        // Default pen types\n        this.penTypes = [\n            {\n                name: localizationTable.freehandPen,\n                factory: _components_builders_FreehandLineBuilder__WEBPACK_IMPORTED_MODULE_7__.makeFreehandLineBuilder,\n            },\n            {\n                name: localizationTable.arrowPen,\n                factory: _components_builders_ArrowBuilder__WEBPACK_IMPORTED_MODULE_12__.makeArrowBuilder,\n            },\n            {\n                name: localizationTable.linePen,\n                factory: _components_builders_LineBuilder__WEBPACK_IMPORTED_MODULE_13__.makeLineBuilder,\n            },\n            {\n                name: localizationTable.filledRectanglePen,\n                factory: _components_builders_RectangleBuilder__WEBPACK_IMPORTED_MODULE_14__.makeFilledRectangleBuilder,\n            },\n            {\n                name: localizationTable.outlinedRectanglePen,\n                factory: _components_builders_RectangleBuilder__WEBPACK_IMPORTED_MODULE_14__.makeOutlinedRectangleBuilder,\n            },\n        ];\n    }\n    setupColorPickers() {\n        const closePickerOverlay = document.createElement('div');\n        closePickerOverlay.className = `${toolbarCSSPrefix}closeColorPickerOverlay`;\n        this.editor.createHTMLOverlay(closePickerOverlay);\n        (0,_melloware_coloris__WEBPACK_IMPORTED_MODULE_2__.coloris)({\n            el: '.coloris_input',\n            format: 'hex',\n            selectInput: false,\n            focusInput: false,\n            themeMode: 'auto',\n            swatches: [\n                _Color4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].red.toHexString(),\n                _Color4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].purple.toHexString(),\n                _Color4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].blue.toHexString(),\n                _Color4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].clay.toHexString(),\n                _Color4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].black.toHexString(),\n                _Color4__WEBPACK_IMPORTED_MODULE_3__[\"default\"].white.toHexString(),\n            ],\n        });\n        this.editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ColorPickerToggled, event => {\n            if (event.kind !== _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.ColorPickerToggled) {\n                return;\n            }\n            // Show/hide the overlay. Making the overlay visible gives users a surface to click\n            // on that shows/hides the color picker.\n            closePickerOverlay.style.display = event.open ? 'block' : 'none';\n        });\n    }\n    addActionButton(text, command, parent) {\n        const button = document.createElement('button');\n        button.innerText = text;\n        button.classList.add(`${toolbarCSSPrefix}toolButton`);\n        button.onclick = command;\n        (parent !== null && parent !== void 0 ? parent : this.container).appendChild(button);\n        return button;\n    }\n    addUndoRedoButtons() {\n        const undoRedoGroup = document.createElement('div');\n        undoRedoGroup.classList.add(`${toolbarCSSPrefix}buttonGroup`);\n        const undoButton = this.addActionButton('Undo', () => {\n            this.editor.history.undo();\n        }, undoRedoGroup);\n        const redoButton = this.addActionButton('Redo', () => {\n            this.editor.history.redo();\n        }, undoRedoGroup);\n        this.container.appendChild(undoRedoGroup);\n        undoButton.disabled = true;\n        redoButton.disabled = true;\n        this.editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.UndoRedoStackUpdated, event => {\n            if (event.kind !== _types__WEBPACK_IMPORTED_MODULE_1__.EditorEventType.UndoRedoStackUpdated) {\n                throw new Error('Wrong event type!');\n            }\n            undoButton.disabled = event.undoStackSize === 0;\n            redoButton.disabled = event.redoStackSize === 0;\n        });\n    }\n    addDefaultToolWidgets() {\n        const toolController = this.editor.toolController;\n        for (const tool of toolController.getMatchingTools(_tools_ToolController__WEBPACK_IMPORTED_MODULE_0__.ToolType.Pen)) {\n            if (!(tool instanceof _tools_Pen__WEBPACK_IMPORTED_MODULE_4__[\"default\"])) {\n                throw new Error('All `Pen` tools must have kind === ToolType.Pen');\n            }\n            const widget = new PenWidget(this.editor, tool, this.localizationTable, this.penTypes);\n            widget.addTo(this.container);\n        }\n        for (const tool of toolController.getMatchingTools(_tools_ToolController__WEBPACK_IMPORTED_MODULE_0__.ToolType.Eraser)) {\n            if (!(tool instanceof _tools_Eraser__WEBPACK_IMPORTED_MODULE_5__[\"default\"])) {\n                throw new Error('All Erasers must have kind === ToolType.Eraser!');\n            }\n            (new EraserWidget(this.editor, tool, this.localizationTable)).addTo(this.container);\n        }\n        for (const tool of toolController.getMatchingTools(_tools_ToolController__WEBPACK_IMPORTED_MODULE_0__.ToolType.Selection)) {\n            if (!(tool instanceof _tools_SelectionTool__WEBPACK_IMPORTED_MODULE_6__[\"default\"])) {\n                throw new Error('All SelectionTools must have kind === ToolType.Selection');\n            }\n            (new SelectionWidget(this.editor, tool, this.localizationTable)).addTo(this.container);\n        }\n        for (const tool of toolController.getMatchingTools(_tools_ToolController__WEBPACK_IMPORTED_MODULE_0__.ToolType.TouchPanZoom)) {\n            (new TouchDrawingWidget(this.editor, tool, this.localizationTable)).addTo(this.container);\n        }\n        this.setupColorPickers();\n    }\n    addDefaultActionButtons() {\n        this.addUndoRedoButtons();\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/toolbar/HTMLToolbar.ts?");

/***/ }),

/***/ "../../src/toolbar/localization.ts":
/*!*****************************************!*\
  !*** ../../src/toolbar/localization.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultToolbarLocalization\": () => (/* binding */ defaultToolbarLocalization)\n/* harmony export */ });\nconst defaultToolbarLocalization = {\n    pen: 'Pen',\n    eraser: 'Eraser',\n    select: 'Select',\n    touchDrawing: 'Touch Drawing',\n    thicknessLabel: 'Thickness: ',\n    colorLabel: 'Color: ',\n    resizeImageToSelection: 'Resize image to selection',\n    undo: 'Undo',\n    redo: 'Redo',\n    selectObjectType: 'Object type: ',\n    freehandPen: 'Freehand',\n    arrowPen: 'Arrow',\n    linePen: 'Line',\n    outlinedRectanglePen: 'Outlined rectangle',\n    filledRectanglePen: 'Filled rectangle',\n    dropdownShown: (toolName) => `Dropdown for ${toolName} shown`,\n    dropdownHidden: (toolName) => `Dropdown for ${toolName} hidden`,\n};\n\n\n//# sourceURL=webpack://jsdraw/../../src/toolbar/localization.ts?");

/***/ }),

/***/ "../../src/tools/BaseTool.ts":
/*!***********************************!*\
  !*** ../../src/tools/BaseTool.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BaseTool)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"../../src/types.ts\");\n\nclass BaseTool {\n    constructor(notifier, description) {\n        this.notifier = notifier;\n        this.description = description;\n        this.enabled = true;\n        this.group = null;\n    }\n    onWheel(_event) {\n        return false;\n    }\n    onKeyPress(_event) {\n        return false;\n    }\n    setEnabled(enabled) {\n        var _a;\n        this.enabled = enabled;\n        // Ensure that at most one tool in the group is enabled.\n        if (enabled) {\n            (_a = this.group) === null || _a === void 0 ? void 0 : _a.notifyEnabled(this);\n            this.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolEnabled, {\n                kind: _types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolEnabled,\n                tool: this,\n            });\n        }\n        else {\n            this.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolDisabled, {\n                kind: _types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolDisabled,\n                tool: this,\n            });\n        }\n    }\n    isEnabled() {\n        return this.enabled;\n    }\n    // Connect this tool to a set of other tools, ensuring that at most one\n    // of the tools in the group is enabled.\n    setToolGroup(group) {\n        if (this.isEnabled()) {\n            group.notifyEnabled(this);\n        }\n        this.group = group;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/tools/BaseTool.ts?");

/***/ }),

/***/ "../../src/tools/Eraser.ts":
/*!*********************************!*\
  !*** ../../src/tools/Eraser.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Eraser)\n/* harmony export */ });\n/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseTool */ \"../../src/tools/BaseTool.ts\");\n/* harmony import */ var _geometry_LineSegment2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/LineSegment2 */ \"../../src/geometry/LineSegment2.ts\");\n/* harmony import */ var _commands_Erase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../commands/Erase */ \"../../src/commands/Erase.ts\");\n/* harmony import */ var _ToolController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ToolController */ \"../../src/tools/ToolController.ts\");\n/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Pointer */ \"../../src/Pointer.ts\");\n\n\n\n\n\nclass Eraser extends _BaseTool__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(editor, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.command = null;\n        this.kind = _ToolController__WEBPACK_IMPORTED_MODULE_3__.ToolType.Eraser;\n    }\n    onPointerDown(event) {\n        if (event.allPointers.length === 1 || event.current.device === _Pointer__WEBPACK_IMPORTED_MODULE_4__.PointerDevice.Eraser) {\n            this.lastPoint = event.current.canvasPos;\n            this.toRemove = [];\n            return true;\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        var _a;\n        const currentPoint = event.current.canvasPos;\n        if (currentPoint.minus(this.lastPoint).magnitude() === 0) {\n            return;\n        }\n        const line = new _geometry_LineSegment2__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.lastPoint, currentPoint);\n        const region = line.bbox;\n        // Remove any intersecting elements.\n        this.toRemove.push(...this.editor.image\n            .getElementsIntersectingRegion(region).filter(component => {\n            return component.intersects(line);\n        }));\n        (_a = this.command) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n        this.command = new _commands_Erase__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.toRemove);\n        this.command.apply(this.editor);\n        this.lastPoint = currentPoint;\n    }\n    onPointerUp(_event) {\n        var _a;\n        if (this.command && this.toRemove.length > 0) {\n            (_a = this.command) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n            // Dispatch the command to make it undo-able\n            this.editor.dispatch(this.command);\n        }\n        this.command = null;\n    }\n    onGestureCancel() {\n        var _a;\n        (_a = this.command) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n        this.command = null;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/tools/Eraser.ts?");

/***/ }),

/***/ "../../src/tools/PanZoom.ts":
/*!**********************************!*\
  !*** ../../src/tools/PanZoom.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PanZoomMode\": () => (/* binding */ PanZoomMode),\n/* harmony export */   \"default\": () => (/* binding */ PanZoom)\n/* harmony export */ });\n/* harmony import */ var _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Mat33 */ \"../../src/geometry/Mat33.ts\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _geometry_Vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/Vec3 */ \"../../src/geometry/Vec3.ts\");\n/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Pointer */ \"../../src/Pointer.ts\");\n/* harmony import */ var _Viewport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Viewport */ \"../../src/Viewport.ts\");\n/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseTool */ \"../../src/tools/BaseTool.ts\");\n/* harmony import */ var _ToolController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ToolController */ \"../../src/tools/ToolController.ts\");\n\n\n\n\n\n\n\nvar PanZoomMode;\n(function (PanZoomMode) {\n    // Handle one-pointer gestures (touchscreen only unless AnyDevice is set)\n    PanZoomMode[PanZoomMode[\"OneFingerGestures\"] = 1] = \"OneFingerGestures\";\n    // Handle two-pointer gestures (touchscreen only unless AnyDevice is set)\n    PanZoomMode[PanZoomMode[\"TwoFingerGestures\"] = 2] = \"TwoFingerGestures\";\n    // / Handle gestures from any device, rather than just touch\n    PanZoomMode[PanZoomMode[\"AnyDevice\"] = 4] = \"AnyDevice\";\n})(PanZoomMode || (PanZoomMode = {}));\nclass PanZoom extends _BaseTool__WEBPACK_IMPORTED_MODULE_5__[\"default\"] {\n    constructor(editor, mode, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.mode = mode;\n        this.kind = _ToolController__WEBPACK_IMPORTED_MODULE_6__.ToolType.PanZoom;\n        this.transform = null;\n        if (mode === PanZoomMode.OneFingerGestures) {\n            this.kind = _ToolController__WEBPACK_IMPORTED_MODULE_6__.ToolType.TouchPanZoom;\n        }\n    }\n    // Returns information about the pointers in a gesture\n    computePinchData(p1, p2) {\n        const screenBetween = p2.screenPos.minus(p1.screenPos);\n        const angle = screenBetween.angle();\n        const dist = screenBetween.magnitude();\n        const canvasCenter = p2.canvasPos.plus(p1.canvasPos).times(0.5);\n        const screenCenter = p2.screenPos.plus(p1.screenPos).times(0.5);\n        return { canvasCenter, screenCenter, angle, dist };\n    }\n    pointersHaveCorrectDeviceType(pointers) {\n        return this.mode & PanZoomMode.AnyDevice || pointers.every(pointer => pointer.device === _Pointer__WEBPACK_IMPORTED_MODULE_3__.PointerDevice.Touch);\n    }\n    onPointerDown({ allPointers }) {\n        var _a;\n        let handlingGesture = false;\n        if (!this.pointersHaveCorrectDeviceType(allPointers)) {\n            handlingGesture = false;\n        }\n        else if (allPointers.length === 2 && this.mode & PanZoomMode.TwoFingerGestures) {\n            const { screenCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);\n            this.lastAngle = angle;\n            this.lastDist = dist;\n            this.lastScreenCenter = screenCenter;\n            handlingGesture = true;\n        }\n        else if (allPointers.length === 1 && this.mode & PanZoomMode.OneFingerGestures) {\n            this.lastScreenCenter = allPointers[0].screenPos;\n            handlingGesture = true;\n        }\n        if (handlingGesture) {\n            (_a = this.transform) !== null && _a !== void 0 ? _a : (this.transform = new _Viewport__WEBPACK_IMPORTED_MODULE_4__.Viewport.ViewportTransform(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity));\n        }\n        return handlingGesture;\n    }\n    // Returns the change in position of the center of the given group of pointers.\n    // Assumes this.lastScreenCenter has been set appropriately.\n    getCenterDelta(screenCenter) {\n        // Use transformVec3 to avoid translating the delta\n        const delta = this.editor.viewport.screenToCanvasTransform.transformVec3(screenCenter.minus(this.lastScreenCenter));\n        return delta;\n    }\n    handleTwoFingerMove(allPointers) {\n        const { screenCenter, canvasCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);\n        const delta = this.getCenterDelta(screenCenter);\n        const transformUpdate = _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(delta)\n            .rightMul(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scaling2D(dist / this.lastDist, canvasCenter))\n            .rightMul(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].zRotation(angle - this.lastAngle, canvasCenter));\n        this.lastScreenCenter = screenCenter;\n        this.lastDist = dist;\n        this.lastAngle = angle;\n        this.transform = new _Viewport__WEBPACK_IMPORTED_MODULE_4__.Viewport.ViewportTransform(this.transform.transform.rightMul(transformUpdate));\n    }\n    handleOneFingerMove(pointer) {\n        const delta = this.getCenterDelta(pointer.screenPos);\n        this.transform = new _Viewport__WEBPACK_IMPORTED_MODULE_4__.Viewport.ViewportTransform(this.transform.transform.rightMul(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(delta)));\n        this.lastScreenCenter = pointer.screenPos;\n    }\n    onPointerMove({ allPointers }) {\n        var _a;\n        (_a = this.transform) !== null && _a !== void 0 ? _a : (this.transform = new _Viewport__WEBPACK_IMPORTED_MODULE_4__.Viewport.ViewportTransform(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity));\n        const lastTransform = this.transform;\n        if (allPointers.length === 2 && this.mode & PanZoomMode.TwoFingerGestures) {\n            this.handleTwoFingerMove(allPointers);\n        }\n        else if (allPointers.length === 1 && this.mode & PanZoomMode.OneFingerGestures) {\n            this.handleOneFingerMove(allPointers[0]);\n        }\n        lastTransform.unapply(this.editor);\n        this.transform.apply(this.editor);\n    }\n    onPointerUp(_event) {\n        if (this.transform) {\n            this.transform.unapply(this.editor);\n            this.editor.dispatch(this.transform, false);\n        }\n        this.transform = null;\n    }\n    onGestureCancel() {\n        var _a;\n        (_a = this.transform) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n        this.transform = null;\n    }\n    // Applies [transformUpdate] to the editor. This stacks on top of the\n    // current transformation, if it exists.\n    updateTransform(transformUpdate) {\n        var _a;\n        let newTransform = transformUpdate;\n        if (this.transform) {\n            newTransform = this.transform.transform.rightMul(transformUpdate);\n        }\n        (_a = this.transform) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n        this.transform = new _Viewport__WEBPACK_IMPORTED_MODULE_4__.Viewport.ViewportTransform(newTransform);\n        this.transform.apply(this.editor);\n    }\n    onWheel({ delta, screenPos }) {\n        if (this.transform === null) {\n            this.transform = new _Viewport__WEBPACK_IMPORTED_MODULE_4__.Viewport.ViewportTransform(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity);\n        }\n        const canvasPos = this.editor.viewport.screenToCanvas(screenPos);\n        const toCanvas = this.editor.viewport.screenToCanvasTransform;\n        // Transform without including translation\n        const translation = toCanvas.transformVec3(_geometry_Vec3__WEBPACK_IMPORTED_MODULE_2__[\"default\"].of(-delta.x, -delta.y, 0));\n        const pinchZoomScaleFactor = 1.04;\n        const transformUpdate = _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scaling2D(Math.pow(pinchZoomScaleFactor, -delta.z), canvasPos).rightMul(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(translation));\n        this.updateTransform(transformUpdate);\n        return true;\n    }\n    onKeyPress({ key }) {\n        let translation = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.zero;\n        let scale = 1;\n        let rotation = 0;\n        // Keyboard shortcut handling\n        switch (key) {\n            case 'a':\n            case 'h':\n            case 'ArrowLeft':\n                translation = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(-1, 0);\n                break;\n            case 'd':\n            case 'l':\n            case 'ArrowRight':\n                translation = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(1, 0);\n                break;\n            case 'k':\n            case 'ArrowUp':\n                translation = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0, -1);\n                break;\n            case 'j':\n            case 'ArrowDown':\n                translation = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_1__.Vec2.of(0, 1);\n                break;\n            case 'w':\n                scale = 1 / 2;\n                break;\n            case 's':\n                scale = 2;\n                break;\n            case 'r':\n                rotation = 1;\n                break;\n            case 'R':\n                rotation = -1;\n                break;\n            default:\n                return false;\n        }\n        // For each keypress,\n        translation = translation.times(30); // Move at most 30 units\n        rotation *= Math.PI / 8; // Rotate at most a sixteenth of a rotation\n        // Transform the canvas, not the viewport:\n        translation = translation.times(-1);\n        rotation = rotation * -1;\n        scale = 1 / scale;\n        const toCanvas = this.editor.viewport.screenToCanvasTransform;\n        // Transform without translating (treat toCanvas as a linear instead of\n        // an affine transformation).\n        translation = toCanvas.transformVec3(translation);\n        // Rotate/scale about the center of the canvas\n        const transformCenter = this.editor.viewport.visibleRect.center;\n        const transformUpdate = _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scaling2D(scale, transformCenter).rightMul(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].zRotation(rotation, transformCenter)).rightMul(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(translation));\n        this.updateTransform(transformUpdate);\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/tools/PanZoom.ts?");

/***/ }),

/***/ "../../src/tools/Pen.ts":
/*!******************************!*\
  !*** ../../src/tools/Pen.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pen)\n/* harmony export */ });\n/* harmony import */ var _EditorImage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditorImage */ \"../../src/EditorImage.ts\");\n/* harmony import */ var _Pointer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Pointer */ \"../../src/Pointer.ts\");\n/* harmony import */ var _components_builders_FreehandLineBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/builders/FreehandLineBuilder */ \"../../src/components/builders/FreehandLineBuilder.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types */ \"../../src/types.ts\");\n/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BaseTool */ \"../../src/tools/BaseTool.ts\");\n/* harmony import */ var _ToolController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ToolController */ \"../../src/tools/ToolController.ts\");\n\n\n\n\n\n\nclass Pen extends _BaseTool__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    constructor(editor, description, style) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.style = style;\n        this.builder = null;\n        this.builderFactory = _components_builders_FreehandLineBuilder__WEBPACK_IMPORTED_MODULE_2__.makeFreehandLineBuilder;\n        this.lastPoint = null;\n        this.kind = _ToolController__WEBPACK_IMPORTED_MODULE_5__.ToolType.Pen;\n    }\n    getPressureMultiplier() {\n        return 1 / this.editor.viewport.getScaleFactor() * this.style.thickness;\n    }\n    getStrokePoint(pointer) {\n        var _a;\n        const minPressure = 0.3;\n        const pressure = Math.max((_a = pointer.pressure) !== null && _a !== void 0 ? _a : 1.0, minPressure);\n        return {\n            pos: pointer.canvasPos,\n            width: pressure * this.getPressureMultiplier(),\n            color: this.style.color,\n            time: pointer.timeStamp,\n        };\n    }\n    previewStroke() {\n        var _a;\n        this.editor.clearWetInk();\n        (_a = this.builder) === null || _a === void 0 ? void 0 : _a.preview(this.editor.display.getWetInkRenderer());\n    }\n    addPointToStroke(point) {\n        if (!this.builder) {\n            throw new Error('No stroke is currently being generated.');\n        }\n        this.builder.addPoint(point);\n        this.lastPoint = point;\n        this.previewStroke();\n    }\n    onPointerDown({ current, allPointers }) {\n        if (current.device === _Pointer__WEBPACK_IMPORTED_MODULE_1__.PointerDevice.Eraser) {\n            return false;\n        }\n        if (allPointers.length === 1 || current.device === _Pointer__WEBPACK_IMPORTED_MODULE_1__.PointerDevice.Pen) {\n            this.builder = this.builderFactory(this.getStrokePoint(current), this.editor.viewport);\n            return true;\n        }\n        return false;\n    }\n    onPointerMove({ current }) {\n        this.addPointToStroke(this.getStrokePoint(current));\n    }\n    onPointerUp({ current }) {\n        var _a, _b;\n        if (!this.builder) {\n            return;\n        }\n        // onPointerUp events can have zero pressure. Use the last pressure instead.\n        const currentPoint = this.getStrokePoint(current);\n        const strokePoint = Object.assign(Object.assign({}, currentPoint), { width: (_b = (_a = this.lastPoint) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : currentPoint.width });\n        this.addPointToStroke(strokePoint);\n        if (this.builder && current.isPrimary) {\n            const stroke = this.builder.build();\n            this.previewStroke();\n            const canFlatten = true;\n            const action = new _EditorImage__WEBPACK_IMPORTED_MODULE_0__[\"default\"].AddElementCommand(stroke, canFlatten);\n            this.editor.dispatch(action);\n        }\n        this.builder = null;\n        this.editor.clearWetInk();\n    }\n    onGestureCancel() {\n        this.editor.clearWetInk();\n    }\n    noteUpdated() {\n        this.editor.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_3__.EditorEventType.ToolUpdated, {\n            kind: _types__WEBPACK_IMPORTED_MODULE_3__.EditorEventType.ToolUpdated,\n            tool: this,\n        });\n    }\n    setColor(color) {\n        if (color.toHexString() !== this.style.color.toHexString()) {\n            this.style = Object.assign(Object.assign({}, this.style), { color });\n            this.noteUpdated();\n        }\n    }\n    setThickness(thickness) {\n        if (thickness !== this.style.thickness) {\n            this.style = Object.assign(Object.assign({}, this.style), { thickness });\n            this.noteUpdated();\n        }\n    }\n    setStrokeFactory(factory) {\n        if (factory !== this.builderFactory) {\n            this.builderFactory = factory;\n            this.noteUpdated();\n        }\n    }\n    getThickness() { return this.style.thickness; }\n    getColor() { return this.style.color; }\n    getStrokeFactory() { return this.builderFactory; }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/tools/Pen.ts?");

/***/ }),

/***/ "../../src/tools/SelectionTool.ts":
/*!****************************************!*\
  !*** ../../src/tools/SelectionTool.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SelectionTool)\n/* harmony export */ });\n/* harmony import */ var _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Mat33 */ \"../../src/geometry/Mat33.ts\");\n/* harmony import */ var _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/Rect2 */ \"../../src/geometry/Rect2.ts\");\n/* harmony import */ var _geometry_Vec2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/Vec2 */ \"../../src/geometry/Vec2.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types */ \"../../src/types.ts\");\n/* harmony import */ var _Viewport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Viewport */ \"../../src/Viewport.ts\");\n/* harmony import */ var _BaseTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BaseTool */ \"../../src/tools/BaseTool.ts\");\n/* harmony import */ var _ToolController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ToolController */ \"../../src/tools/ToolController.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n// import Mat33 from \"../geometry/Mat33\";\n\n\n\n\n\n\nconst handleScreenSize = 30;\nconst styles = `\n\t.handleOverlay {\n\t}\n\n\t.handleOverlay > .selectionBox {\n\t\tposition: absolute;\n\t\tz-index: 0;\n\t\ttransform-origin: center;\n\t}\n\n\t.handleOverlay > .selectionBox .draggableBackground {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\n\t\tbackground-color: var(--secondary-background-color);\n\t\topacity: 0.8;\n\t\tborder: 1px solid var(--primary-background-color);\n\t}\n\n\t.handleOverlay .resizeCorner {\n\t\twidth: ${handleScreenSize}px;\n\t\theight: ${handleScreenSize}px;\n\t\tmargin-right: -${handleScreenSize / 2}px;\n\t\tmargin-bottom: -${handleScreenSize / 2}px;\n\n\t\tposition: absolute;\n\t\tbottom: 0;\n\t\tright: 0;\n\n\t\topacity: 0.8;\n\t\tbackground-color: var(--primary-background-color);\n\t\tborder: 1px solid var(--primary-foreground-color);\n\t}\n\n\t.handleOverlay > .selectionBox .rotateCircleContainer {\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tbottom: 50%;\n\t\tleft: 50%;\n\t\tright: 50%;\n\t}\n\n\t.handleOverlay .rotateCircle {\n\t\twidth: ${handleScreenSize}px;\n\t\theight: ${handleScreenSize}px;\n\t\tmargin-left: -${handleScreenSize / 2}px;\n\t\tmargin-top: -${handleScreenSize / 2}px;\n\t\topacity: 0.8;\n\n\t\tborder: 1px solid var(--primary-foreground-color);\n\t\tbackground-color: var(--primary-background-color);\n\t\tborder-radius: 100%;\n\t}\n`;\nconst makeDraggable = (element, onDrag, onDragEnd) => {\n    element.style.touchAction = 'none';\n    let down = false;\n    // Work around a Safari bug\n    element.addEventListener('touchstart', evt => evt.preventDefault());\n    let lastX;\n    let lastY;\n    element.addEventListener('pointerdown', event => {\n        if (event.isPrimary) {\n            down = true;\n            element.setPointerCapture(event.pointerId);\n            lastX = event.pageX;\n            lastY = event.pageY;\n            return true;\n        }\n        return false;\n    });\n    element.addEventListener('pointermove', event => {\n        if (event.isPrimary && down) {\n            // Safari/iOS doesn't seem to support movementX/movementY on pointer events.\n            // Calculate manually:\n            const delta = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(event.pageX - lastX, event.pageY - lastY);\n            onDrag(delta, _geometry_Vec2__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(event.offsetX, event.offsetY));\n            lastX = event.pageX;\n            lastY = event.pageY;\n            return true;\n        }\n        return false;\n    });\n    const onPointerEnd = (event) => {\n        if (event.isPrimary) {\n            down = false;\n            onDragEnd();\n            return true;\n        }\n        return false;\n    };\n    element.addEventListener('pointerup', onPointerEnd);\n    element.addEventListener('pointercancel', onPointerEnd);\n};\n// Maximum number of strokes to transform without a re-render.\nconst updateChunkSize = 50;\nclass Selection {\n    constructor(startPoint, editor) {\n        this.startPoint = startPoint;\n        this.editor = editor;\n        this.boxRotation = this.editor.viewport.getRotationAngle();\n        this.selectedElems = [];\n        this.region = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bboxOf([startPoint]);\n        // Create draggable rectangles\n        this.backgroundBox = document.createElement('div');\n        const draggableBackground = document.createElement('div');\n        const resizeCorner = document.createElement('div');\n        this.rotateCircle = document.createElement('div');\n        const rotateCircleContainer = document.createElement('div');\n        this.backgroundBox.classList.add('selectionBox');\n        draggableBackground.classList.add('draggableBackground');\n        resizeCorner.classList.add('resizeCorner');\n        this.rotateCircle.classList.add('rotateCircle');\n        rotateCircleContainer.classList.add('rotateCircleContainer');\n        rotateCircleContainer.appendChild(this.rotateCircle);\n        this.backgroundBox.appendChild(draggableBackground);\n        this.backgroundBox.appendChild(rotateCircleContainer);\n        this.backgroundBox.appendChild(resizeCorner);\n        this.transformationCommands = [];\n        this.transform = _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity;\n        makeDraggable(draggableBackground, (deltaPosition) => {\n            this.handleBackgroundDrag(deltaPosition);\n        }, () => this.finishDragging());\n        makeDraggable(resizeCorner, (deltaPosition) => {\n            this.handleResizeCornerDrag(deltaPosition);\n        }, () => this.finishDragging());\n        makeDraggable(this.rotateCircle, (_deltaPosition, offset) => {\n            this.handleRotateCircleDrag(offset);\n        }, () => this.finishDragging());\n    }\n    // Note a small change in the position of this' background while dragging\n    // At the end of a drag, changes should be applied by calling this.finishDragging()\n    handleBackgroundDrag(deltaPosition) {\n        // Re-scale the change in position\n        // (use a Vec3 transform to avoid translating deltaPosition)\n        deltaPosition = this.editor.viewport.screenToCanvasTransform.transformVec3(deltaPosition);\n        // Snap position to a multiple of 10 (additional decimal points lead to larger files).\n        deltaPosition = this.editor.viewport.roundPoint(deltaPosition);\n        this.region = this.region.translatedBy(deltaPosition);\n        this.transform = this.transform.rightMul(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(deltaPosition));\n        this.previewTransformCmds();\n    }\n    handleResizeCornerDrag(deltaPosition) {\n        deltaPosition = this.editor.viewport.screenToCanvasTransform.transformVec3(deltaPosition);\n        deltaPosition = this.editor.viewport.roundPoint(deltaPosition);\n        const oldWidth = this.region.w;\n        const oldHeight = this.region.h;\n        const newSize = this.region.size.plus(deltaPosition);\n        if (newSize.y > 0 && newSize.x > 0) {\n            this.region = this.region.resizedTo(newSize);\n            const scaleFactor = _geometry_Vec2__WEBPACK_IMPORTED_MODULE_2__.Vec2.of(this.region.w / oldWidth, this.region.h / oldHeight);\n            const currentTransfm = _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scaling2D(scaleFactor, this.region.topLeft);\n            this.transform = this.transform.rightMul(currentTransfm);\n            this.previewTransformCmds();\n        }\n    }\n    handleRotateCircleDrag(offset) {\n        this.boxRotation = this.boxRotation % (2 * Math.PI);\n        if (this.boxRotation < 0) {\n            this.boxRotation += 2 * Math.PI;\n        }\n        let targetRotation = offset.angle();\n        targetRotation = targetRotation % (2 * Math.PI);\n        if (targetRotation < 0) {\n            targetRotation += 2 * Math.PI;\n        }\n        let deltaRotation = (targetRotation - this.boxRotation);\n        const rotationStep = Math.PI / 12;\n        if (Math.abs(deltaRotation) < rotationStep || !isFinite(deltaRotation)) {\n            return;\n        }\n        else {\n            const rotationDirection = Math.sign(deltaRotation);\n            // Step exactly one rotationStep\n            deltaRotation = Math.floor(Math.abs(deltaRotation) / rotationStep) * rotationStep;\n            deltaRotation *= rotationDirection;\n        }\n        this.transform = this.transform.rightMul(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].zRotation(deltaRotation, this.region.center));\n        this.boxRotation += deltaRotation;\n        this.previewTransformCmds();\n    }\n    computeTransformCommands() {\n        return this.selectedElems.map(elem => {\n            return elem.transformBy(this.transform);\n        });\n    }\n    // Applies the current transformation to the selection\n    finishDragging() {\n        this.transformationCommands.forEach(cmd => {\n            cmd.unapply(this.editor);\n        });\n        const fullTransform = this.transform;\n        const inverseTransform = this.transform.inverse();\n        const deltaBoxRotation = this.boxRotation;\n        const currentTransfmCommands = this.computeTransformCommands();\n        // Reset for the next drag\n        this.transformationCommands = [];\n        this.transform = _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].identity;\n        this.region = this.region.transformedBoundingBox(inverseTransform);\n        // Make the commands undo-able\n        this.editor.dispatch({\n            apply: (editor) => __awaiter(this, void 0, void 0, function* () {\n                // Approximate the new selection\n                this.region = this.region.transformedBoundingBox(fullTransform);\n                this.boxRotation += deltaBoxRotation;\n                this.updateUI();\n                yield editor.asyncApplyCommands(currentTransfmCommands, updateChunkSize);\n                this.recomputeRegion();\n                this.updateUI();\n            }),\n            unapply: (editor) => __awaiter(this, void 0, void 0, function* () {\n                this.region = this.region.transformedBoundingBox(inverseTransform);\n                this.boxRotation -= deltaBoxRotation;\n                this.updateUI();\n                yield editor.asyncUnapplyCommands(currentTransfmCommands, updateChunkSize);\n                this.recomputeRegion();\n                this.updateUI();\n            }),\n            description(localizationTable) {\n                return localizationTable.transformedElements(currentTransfmCommands.length);\n            },\n        });\n    }\n    // Preview the effects of the current transformation on the selection\n    previewTransformCmds() {\n        // Don't render what we're moving if it's likely to be slow.\n        if (this.selectedElems.length > updateChunkSize) {\n            this.updateUI();\n            return;\n        }\n        this.transformationCommands.forEach(cmd => cmd.unapply(this.editor));\n        this.transformationCommands = this.computeTransformCommands();\n        this.transformationCommands.forEach(cmd => cmd.apply(this.editor));\n        this.updateUI();\n    }\n    appendBackgroundBoxTo(elem) {\n        if (this.backgroundBox.parentElement) {\n            this.backgroundBox.remove();\n        }\n        elem.appendChild(this.backgroundBox);\n    }\n    setToPoint(point) {\n        this.region = this.region.grownToPoint(point);\n        this.recomputeBoxRotation();\n        this.updateUI();\n    }\n    cancelSelection() {\n        if (this.backgroundBox.parentElement) {\n            this.backgroundBox.remove();\n        }\n        this.region = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__[\"default\"].empty;\n    }\n    // Find the objects corresponding to this in the document,\n    // select them.\n    // Returns false iff nothing was selected.\n    resolveToObjects() {\n        // Grow the rectangle, if necessary\n        if (this.region.w === 0 || this.region.h === 0) {\n            const padding = this.editor.viewport.visibleRect.maxDimension / 100;\n            this.region = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bboxOf(this.region.corners, padding);\n        }\n        this.selectedElems = this.editor.image.getElementsIntersectingRegion(this.region).filter(elem => {\n            if (this.region.containsRect(elem.getBBox())) {\n                return true;\n            }\n            else if (this.region.getEdges().some(edge => elem.intersects(edge))) {\n                return true;\n            }\n            return false;\n        });\n        // Find the bounding box of all selected elements.\n        if (!this.recomputeRegion()) {\n            return false;\n        }\n        this.updateUI();\n        return true;\n    }\n    // Recompute this' region from the selected elements. Resets rotation to zero.\n    // Returns false if the selection is empty.\n    recomputeRegion() {\n        const newRegion = this.selectedElems.reduce((accumulator, elem) => {\n            return (accumulator !== null && accumulator !== void 0 ? accumulator : elem.getBBox()).union(elem.getBBox());\n        }, null);\n        if (!newRegion) {\n            this.cancelSelection();\n            return false;\n        }\n        this.region = newRegion;\n        const minSize = this.getMinCanvasSize();\n        if (this.region.w < minSize || this.region.h < minSize) {\n            // Add padding\n            const padding = minSize / 2;\n            this.region = _geometry_Rect2__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bboxOf(this.region.corners, padding);\n        }\n        this.recomputeBoxRotation();\n        return true;\n    }\n    getMinCanvasSize() {\n        const canvasHandleSize = handleScreenSize / this.editor.viewport.getScaleFactor();\n        return canvasHandleSize * 2;\n    }\n    recomputeBoxRotation() {\n        this.boxRotation = this.editor.viewport.getRotationAngle();\n    }\n    getSelectedItemCount() {\n        return this.selectedElems.length;\n    }\n    updateUI() {\n        if (!this.backgroundBox) {\n            return;\n        }\n        const rightSideDirection = this.region.topRight.minus(this.region.bottomRight);\n        const topSideDirection = this.region.topLeft.minus(this.region.topRight);\n        const toScreen = this.editor.viewport.canvasToScreenTransform;\n        const centerOnScreen = toScreen.transformVec2(this.region.center);\n        const heightOnScreen = toScreen.transformVec3(rightSideDirection).magnitude();\n        const widthOnScreen = toScreen.transformVec3(topSideDirection).magnitude();\n        this.backgroundBox.style.marginLeft = `${centerOnScreen.x - widthOnScreen / 2}px`;\n        this.backgroundBox.style.marginTop = `${centerOnScreen.y - heightOnScreen / 2}px`;\n        this.backgroundBox.style.width = `${widthOnScreen}px`;\n        this.backgroundBox.style.height = `${heightOnScreen}px`;\n        const rotationDeg = this.boxRotation * 180 / Math.PI;\n        this.backgroundBox.style.transform = `rotate(${rotationDeg}deg)`;\n        this.rotateCircle.style.transform = `rotate(${-rotationDeg}deg)`;\n    }\n}\nclass SelectionTool extends _BaseTool__WEBPACK_IMPORTED_MODULE_5__[\"default\"] {\n    constructor(editor, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.kind = _ToolController__WEBPACK_IMPORTED_MODULE_6__.ToolType.Selection;\n        this.handleOverlay = document.createElement('div');\n        editor.createHTMLOverlay(this.handleOverlay);\n        editor.addStyleSheet(styles);\n        this.handleOverlay.style.display = 'none';\n        this.handleOverlay.classList.add('handleOverlay');\n        editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_3__.EditorEventType.ViewportChanged, _data => {\n            var _a, _b;\n            (_a = this.selectionBox) === null || _a === void 0 ? void 0 : _a.recomputeRegion();\n            (_b = this.selectionBox) === null || _b === void 0 ? void 0 : _b.updateUI();\n        });\n    }\n    onPointerDown(event) {\n        if (event.allPointers.length === 1 && event.current.isPrimary) {\n            this.prevSelectionBox = this.selectionBox;\n            this.selectionBox = new Selection(event.current.canvasPos, this.editor);\n            // Remove any previous selection rects\n            this.handleOverlay.replaceChildren();\n            this.selectionBox.appendBackgroundBoxTo(this.handleOverlay);\n            return true;\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        if (!this.selectionBox)\n            return;\n        this.selectionBox.setToPoint(event.current.canvasPos);\n    }\n    onGestureEnd() {\n        if (!this.selectionBox)\n            return;\n        // Expand/shrink the selection rectangle, if applicable\n        const hasSelection = this.selectionBox.resolveToObjects();\n        // Note that the selection has changed\n        this.editor.notifier.dispatch(_types__WEBPACK_IMPORTED_MODULE_3__.EditorEventType.ToolUpdated, {\n            kind: _types__WEBPACK_IMPORTED_MODULE_3__.EditorEventType.ToolUpdated,\n            tool: this,\n        });\n        if (hasSelection) {\n            const visibleRect = this.editor.viewport.visibleRect;\n            const selectionRect = this.selectionBox.region;\n            this.editor.announceForAccessibility(this.editor.localization.selectedElements(this.selectionBox.getSelectedItemCount()));\n            // Try to move the selection within the center 2/3rds of the viewport.\n            const targetRect = visibleRect.transformedBoundingBox(_geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scaling2D(2 / 3, visibleRect.center));\n            // Ensure that the selection fits within the target\n            if (targetRect.w < selectionRect.w || targetRect.h < selectionRect.h) {\n                const multiplier = Math.max(selectionRect.w / targetRect.w, selectionRect.h / targetRect.h);\n                const visibleRectTransform = _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scaling2D(multiplier, targetRect.topLeft);\n                const viewportContentTransform = visibleRectTransform.inverse();\n                (new _Viewport__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ViewportTransform(viewportContentTransform)).apply(this.editor);\n            }\n            // Ensure that the top left is visible\n            if (!targetRect.containsRect(selectionRect)) {\n                // target position - current position\n                const translation = selectionRect.center.minus(targetRect.center);\n                const visibleRectTransform = _geometry_Mat33__WEBPACK_IMPORTED_MODULE_0__[\"default\"].translation(translation);\n                const viewportContentTransform = visibleRectTransform.inverse();\n                (new _Viewport__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ViewportTransform(viewportContentTransform)).apply(this.editor);\n            }\n        }\n    }\n    onPointerUp(event) {\n        if (!this.selectionBox)\n            return;\n        this.selectionBox.setToPoint(event.current.canvasPos);\n        this.onGestureEnd();\n    }\n    onGestureCancel() {\n        var _a, _b;\n        // Revert to the previous selection, if any.\n        (_a = this.selectionBox) === null || _a === void 0 ? void 0 : _a.cancelSelection();\n        this.selectionBox = this.prevSelectionBox;\n        (_b = this.selectionBox) === null || _b === void 0 ? void 0 : _b.appendBackgroundBoxTo(this.handleOverlay);\n    }\n    setEnabled(enabled) {\n        super.setEnabled(enabled);\n        // Clear the selection\n        this.handleOverlay.replaceChildren();\n        this.selectionBox = null;\n        this.handleOverlay.style.display = enabled ? 'block' : 'none';\n    }\n    // Get the object responsible for displaying this' selection.\n    getSelection() {\n        return this.selectionBox;\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/tools/SelectionTool.ts?");

/***/ }),

/***/ "../../src/tools/ToolController.ts":
/*!*****************************************!*\
  !*** ../../src/tools/ToolController.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ToolType\": () => (/* binding */ ToolType),\n/* harmony export */   \"default\": () => (/* binding */ ToolController)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"../../src/types.ts\");\n/* harmony import */ var _PanZoom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PanZoom */ \"../../src/tools/PanZoom.ts\");\n/* harmony import */ var _Pen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pen */ \"../../src/tools/Pen.ts\");\n/* harmony import */ var _ToolEnabledGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ToolEnabledGroup */ \"../../src/tools/ToolEnabledGroup.ts\");\n/* harmony import */ var _Eraser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Eraser */ \"../../src/tools/Eraser.ts\");\n/* harmony import */ var _SelectionTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SelectionTool */ \"../../src/tools/SelectionTool.ts\");\n/* harmony import */ var _Color4__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Color4 */ \"../../src/Color4.ts\");\n\n\n\n\n\n\n\nvar ToolType;\n(function (ToolType) {\n    ToolType[ToolType[\"TouchPanZoom\"] = 0] = \"TouchPanZoom\";\n    ToolType[ToolType[\"Pen\"] = 1] = \"Pen\";\n    ToolType[ToolType[\"Selection\"] = 2] = \"Selection\";\n    ToolType[ToolType[\"Eraser\"] = 3] = \"Eraser\";\n    ToolType[ToolType[\"PanZoom\"] = 4] = \"PanZoom\";\n})(ToolType || (ToolType = {}));\nclass ToolController {\n    constructor(editor, localization) {\n        const primaryToolEnabledGroup = new _ToolEnabledGroup__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n        const touchPanZoom = new _PanZoom__WEBPACK_IMPORTED_MODULE_1__[\"default\"](editor, _PanZoom__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.OneFingerGestures, localization.touchPanTool);\n        const primaryPenTool = new _Pen__WEBPACK_IMPORTED_MODULE_2__[\"default\"](editor, localization.penTool(1), { color: _Color4__WEBPACK_IMPORTED_MODULE_6__[\"default\"].purple, thickness: 16 });\n        const primaryTools = [\n            new _SelectionTool__WEBPACK_IMPORTED_MODULE_5__[\"default\"](editor, localization.selectionTool),\n            new _Eraser__WEBPACK_IMPORTED_MODULE_4__[\"default\"](editor, localization.eraserTool),\n            // Three pens\n            primaryPenTool,\n            new _Pen__WEBPACK_IMPORTED_MODULE_2__[\"default\"](editor, localization.penTool(2), { color: _Color4__WEBPACK_IMPORTED_MODULE_6__[\"default\"].clay, thickness: 8 }),\n            // Highlighter-like pen with width=64\n            new _Pen__WEBPACK_IMPORTED_MODULE_2__[\"default\"](editor, localization.penTool(3), { color: _Color4__WEBPACK_IMPORTED_MODULE_6__[\"default\"].ofRGBA(1, 1, 0, 0.5), thickness: 64 }),\n        ];\n        this.tools = [\n            touchPanZoom,\n            ...primaryTools,\n            new _PanZoom__WEBPACK_IMPORTED_MODULE_1__[\"default\"](editor, _PanZoom__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.TwoFingerGestures | _PanZoom__WEBPACK_IMPORTED_MODULE_1__.PanZoomMode.AnyDevice, localization.twoFingerPanZoomTool),\n        ];\n        primaryTools.forEach(tool => tool.setToolGroup(primaryToolEnabledGroup));\n        touchPanZoom.setEnabled(false);\n        primaryPenTool.setEnabled(true);\n        editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolEnabled, event => {\n            if (event.kind === _types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolEnabled) {\n                editor.announceForAccessibility(localization.toolEnabledAnnouncement(event.tool.description));\n            }\n        });\n        editor.notifier.on(_types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolDisabled, event => {\n            if (event.kind === _types__WEBPACK_IMPORTED_MODULE_0__.EditorEventType.ToolDisabled) {\n                editor.announceForAccessibility(localization.toolDisabledAnnouncement(event.tool.description));\n            }\n        });\n        this.activeTool = null;\n    }\n    // Returns true if the event was handled\n    dispatchInputEvent(event) {\n        var _a, _b;\n        let handled = false;\n        if (event.kind === _types__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerDownEvt) {\n            for (const tool of this.tools) {\n                if (tool.isEnabled() && tool.onPointerDown(event)) {\n                    if (this.activeTool !== tool) {\n                        (_a = this.activeTool) === null || _a === void 0 ? void 0 : _a.onGestureCancel();\n                    }\n                    this.activeTool = tool;\n                    handled = true;\n                    break;\n                }\n            }\n        }\n        else if (event.kind === _types__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerUpEvt) {\n            (_b = this.activeTool) === null || _b === void 0 ? void 0 : _b.onPointerUp(event);\n            this.activeTool = null;\n            handled = true;\n        }\n        else if (event.kind === _types__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.WheelEvt || event.kind === _types__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.KeyPressEvent) {\n            const isKeyPressEvt = event.kind === _types__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.KeyPressEvent;\n            const isWheelEvt = event.kind === _types__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.WheelEvt;\n            for (const tool of this.tools) {\n                if (!tool.isEnabled()) {\n                    continue;\n                }\n                const wheelResult = isWheelEvt && tool.onWheel(event);\n                const keyPressResult = isKeyPressEvt && tool.onKeyPress(event);\n                handled = keyPressResult || wheelResult;\n                if (handled) {\n                    break;\n                }\n            }\n        }\n        else if (this.activeTool !== null) {\n            let allCasesHandledGuard;\n            switch (event.kind) {\n                case _types__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.PointerMoveEvt:\n                    this.activeTool.onPointerMove(event);\n                    break;\n                case _types__WEBPACK_IMPORTED_MODULE_0__.InputEvtType.GestureCancelEvt:\n                    this.activeTool.onGestureCancel();\n                    this.activeTool = null;\n                    break;\n                default:\n                    allCasesHandledGuard = event;\n                    return allCasesHandledGuard;\n            }\n            handled = true;\n        }\n        else {\n            handled = false;\n        }\n        return handled;\n    }\n    getMatchingTools(kind) {\n        return this.tools.filter(tool => tool.kind === kind);\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/tools/ToolController.ts?");

/***/ }),

/***/ "../../src/tools/ToolEnabledGroup.ts":
/*!*******************************************!*\
  !*** ../../src/tools/ToolEnabledGroup.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ToolEnabledGroup)\n/* harmony export */ });\n// Connects a group of tools -- at most one tool in the group must be enabled.\nclass ToolEnabledGroup {\n    constructor() { }\n    notifyEnabled(tool) {\n        var _a;\n        if (tool !== this.activeTool) {\n            (_a = this.activeTool) === null || _a === void 0 ? void 0 : _a.setEnabled(false);\n            this.activeTool = tool;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://jsdraw/../../src/tools/ToolEnabledGroup.ts?");

/***/ }),

/***/ "../../src/tools/localization.ts":
/*!***************************************!*\
  !*** ../../src/tools/localization.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultToolLocalization\": () => (/* binding */ defaultToolLocalization)\n/* harmony export */ });\nconst defaultToolLocalization = {\n    penTool: (penId) => `Pen ${penId}`,\n    selectionTool: 'Selection',\n    eraserTool: 'Eraser',\n    touchPanTool: 'Touch Panning',\n    twoFingerPanZoomTool: 'Panning and Zooming',\n    toolEnabledAnnouncement: (toolName) => `${toolName} enabled`,\n    toolDisabledAnnouncement: (toolName) => `${toolName} disabled`,\n};\n\n\n//# sourceURL=webpack://jsdraw/../../src/tools/localization.ts?");

/***/ }),

/***/ "../../src/types.ts":
/*!**************************!*\
  !*** ../../src/types.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EditorEventType\": () => (/* binding */ EditorEventType),\n/* harmony export */   \"InputEvtType\": () => (/* binding */ InputEvtType)\n/* harmony export */ });\n// Types related to the image editor\nvar InputEvtType;\n(function (InputEvtType) {\n    InputEvtType[InputEvtType[\"PointerDownEvt\"] = 0] = \"PointerDownEvt\";\n    InputEvtType[InputEvtType[\"PointerMoveEvt\"] = 1] = \"PointerMoveEvt\";\n    InputEvtType[InputEvtType[\"PointerUpEvt\"] = 2] = \"PointerUpEvt\";\n    InputEvtType[InputEvtType[\"GestureCancelEvt\"] = 3] = \"GestureCancelEvt\";\n    InputEvtType[InputEvtType[\"WheelEvt\"] = 4] = \"WheelEvt\";\n    InputEvtType[InputEvtType[\"KeyPressEvent\"] = 5] = \"KeyPressEvent\";\n})(InputEvtType || (InputEvtType = {}));\nvar EditorEventType;\n(function (EditorEventType) {\n    EditorEventType[EditorEventType[\"ToolEnabled\"] = 0] = \"ToolEnabled\";\n    EditorEventType[EditorEventType[\"ToolDisabled\"] = 1] = \"ToolDisabled\";\n    EditorEventType[EditorEventType[\"ToolUpdated\"] = 2] = \"ToolUpdated\";\n    EditorEventType[EditorEventType[\"UndoRedoStackUpdated\"] = 3] = \"UndoRedoStackUpdated\";\n    EditorEventType[EditorEventType[\"ObjectAdded\"] = 4] = \"ObjectAdded\";\n    EditorEventType[EditorEventType[\"ViewportChanged\"] = 5] = \"ViewportChanged\";\n    EditorEventType[EditorEventType[\"DisplayResized\"] = 6] = \"DisplayResized\";\n    EditorEventType[EditorEventType[\"ColorPickerToggled\"] = 7] = \"ColorPickerToggled\";\n})(EditorEventType || (EditorEventType = {}));\n\n\n//# sourceURL=webpack://jsdraw/../../src/types.ts?");

/***/ }),

/***/ "../../src/styles.js":
/*!***************************!*\
  !*** ../../src/styles.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Editor_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Editor.css */ \"../../src/Editor.css\");\n/* harmony import */ var _melloware_coloris_dist_coloris_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @melloware/coloris/dist/coloris.css */ \"../../node_modules/@melloware/coloris/dist/coloris.css\");\n\n\n\n\n//# sourceURL=webpack://jsdraw/../../src/styles.js?");

/***/ }),

/***/ "../../node_modules/@melloware/coloris/dist/esm/coloris.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@melloware/coloris/dist/esm/coloris.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"close\": () => (/* binding */ _close),\n/* harmony export */   \"coloris\": () => (/* binding */ _coloris),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"init\": () => (/* binding */ _init),\n/* harmony export */   \"set\": () => (/* binding */ _set),\n/* harmony export */   \"wrap\": () => (/* binding */ _wrap)\n/* harmony export */ });\nvar Coloris = function () {\n  /*!\r\n  * Copyright (c) 2021 Momo Bassit.\r\n  * Licensed under the MIT License (MIT)\r\n  * https://github.com/mdbassit/Coloris\r\n  */\n\n  return function (window, document, Math) {\n    var ctx = document.createElement('canvas').getContext('2d');\n    var currentColor = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 };\n    var container, picker, colorArea, colorAreaDims, colorMarker, colorPreview, colorValue, clearButton,\n    hueSlider, hueMarker, alphaSlider, alphaMarker, currentEl, currentFormat, oldColor;\n\n    // Default settings\n    var settings = {\n      el: '[data-coloris]',\n      parent: 'body',\n      theme: 'default',\n      themeMode: 'light',\n      wrap: true,\n      margin: 2,\n      format: 'hex',\n      formatToggle: false,\n      swatches: [],\n      swatchesOnly: false,\n      alpha: true,\n      forceAlpha: false,\n      focusInput: true,\n      selectInput: false,\n      inline: false,\n      defaultColor: '#000000',\n      clearButton: false,\n      clearLabel: 'Clear',\n      a11y: {\n        open: 'Open color picker',\n        close: 'Close color picker',\n        marker: 'Saturation: {s}. Brightness: {v}.',\n        hueSlider: 'Hue slider',\n        alphaSlider: 'Opacity slider',\n        input: 'Color value field',\n        format: 'Color format',\n        swatch: 'Color swatch',\n        instruction: 'Saturation and brightness selector. Use up, down, left and right arrow keys to select.' } };\n\n\n\n    // Virtual instances cache\n    var instances = {};\n    var currentInstanceId = '';\n    var defaultInstance = {};\n    var hasInstance = false;\n\n    /**\r\n     * Configure the color picker.\r\n     * @param {object} options Configuration options.\r\n     */\n    function configure(options) {\n      if (typeof options !== 'object') {\n        return;\n      }\n\n      for (var key in options) {\n        switch (key) {\n          case 'el':\n            bindFields(options.el);\n            if (options.wrap !== false) {\n              wrapFields(options.el);\n            }\n            break;\n          case 'parent':\n            container = document.querySelector(options.parent);\n            if (container) {\n              container.appendChild(picker);\n              settings.parent = options.parent;\n\n              // document.body is special\n              if (container === document.body) {\n                container = null;\n              }\n            }\n            break;\n          case 'themeMode':\n            settings.themeMode = options.themeMode;\n            if (options.themeMode === 'auto' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {\n              settings.themeMode = 'dark';\n            }\n          // The lack of a break statement is intentional\n          case 'theme':\n            if (options.theme) {\n              settings.theme = options.theme;\n            }\n\n            // Set the theme and color scheme\n            picker.className = \"clr-picker clr-\" + settings.theme + \" clr-\" + settings.themeMode;\n\n            // Update the color picker's position if inline mode is in use\n            if (settings.inline) {\n              updatePickerPosition();\n            }\n            break;\n          case 'margin':\n            options.margin *= 1;\n            settings.margin = !isNaN(options.margin) ? options.margin : settings.margin;\n            break;\n          case 'wrap':\n            if (options.el && options.wrap) {\n              wrapFields(options.el);\n            }\n            break;\n          case 'formatToggle':\n            settings.formatToggle = !!options.formatToggle;\n            getEl('clr-format').style.display = settings.formatToggle ? 'block' : 'none';\n            if (settings.formatToggle) {\n              settings.format = 'auto';\n            }\n            break;\n          case 'swatches':\n            if (Array.isArray(options.swatches)) {(function () {\n                var swatches = [];\n\n                options.swatches.forEach(function (swatch, i) {\n                  swatches.push(\"<button type=\\\"button\\\" id=\\\"clr-swatch-\" + i + \"\\\" aria-labelledby=\\\"clr-swatch-label clr-swatch-\" + i + \"\\\" style=\\\"color: \" + swatch + \";\\\">\" + swatch + \"</button>\");\n                });\n\n                getEl('clr-swatches').innerHTML = swatches.length ? \"<div>\" + swatches.join('') + \"</div>\" : '';\n                settings.swatches = options.swatches.slice();})();\n            }\n            break;\n          case 'swatchesOnly':\n            settings.swatchesOnly = !!options.swatchesOnly;\n            picker.setAttribute('data-minimal', settings.swatchesOnly);\n            break;\n          case 'alpha':\n            settings.alpha = !!options.alpha;\n            picker.setAttribute('data-alpha', settings.alpha);\n            break;\n          case 'inline':\n            settings.inline = !!options.inline;\n            picker.setAttribute('data-inline', settings.inline);\n\n            if (settings.inline) {\n              var defaultColor = options.defaultColor || settings.defaultColor;\n\n              currentFormat = getColorFormatFromStr(defaultColor);\n              updatePickerPosition();\n              setColorFromStr(defaultColor);\n            }\n            break;\n          case 'clearButton':\n            // Backward compatibility\n            if (typeof options.clearButton === 'object') {\n              if (options.clearButton.label) {\n                settings.clearLabel = options.clearButton.label;\n                clearButton.innerHTML = settings.clearLabel;\n              }\n\n              options.clearButton = options.clearButton.show;\n            }\n\n            settings.clearButton = !!options.clearButton;\n            clearButton.style.display = settings.clearButton ? 'block' : 'none';\n            break;\n          case 'clearLabel':\n            settings.clearLabel = options.clearLabel;\n            clearButton.innerHTML = settings.clearLabel;\n            break;\n          case 'a11y':\n            var labels = options.a11y;\n            var update = false;\n\n            if (typeof labels === 'object') {\n              for (var label in labels) {\n                if (labels[label] && settings.a11y[label]) {\n                  settings.a11y[label] = labels[label];\n                  update = true;\n                }\n              }\n            }\n\n            if (update) {\n              var openLabel = getEl('clr-open-label');\n              var swatchLabel = getEl('clr-swatch-label');\n\n              openLabel.innerHTML = settings.a11y.open;\n              swatchLabel.innerHTML = settings.a11y.swatch;\n              colorPreview.setAttribute('aria-label', settings.a11y.close);\n              hueSlider.setAttribute('aria-label', settings.a11y.hueSlider);\n              alphaSlider.setAttribute('aria-label', settings.a11y.alphaSlider);\n              colorValue.setAttribute('aria-label', settings.a11y.input);\n              colorArea.setAttribute('aria-label', settings.a11y.instruction);\n            }\n          default:\n            settings[key] = options[key];}\n\n      }\n    }\n\n    /**\r\n     * Add or update a virtual instance.\r\n     * @param {String} selector The CSS selector of the elements to which the instance is attached.\r\n     * @param {Object} options Per-instance options to apply.\r\n     */\n    function setVirtualInstance(selector, options) {\n      if (typeof selector === 'string' && typeof options === 'object') {\n        instances[selector] = options;\n        hasInstance = true;\n      }\n    }\n\n    /**\r\n     * Remove a virtual instance.\r\n     * @param {String} selector The CSS selector of the elements to which the instance is attached.\r\n     */\n    function removeVirtualInstance(selector) {\n      delete instances[selector];\n\n      if (Object.keys(instances).length === 0) {\n        hasInstance = false;\n\n        if (selector === currentInstanceId) {\n          resetVirtualInstance();\n        }\n      }\n    }\n\n    /**\r\n     * Attach a virtual instance to an element if it matches a selector.\r\n     * @param {Object} element Target element that will receive a virtual instance if applicable.\r\n     */\n    function attachVirtualInstance(element) {\n      if (hasInstance) {\n        // These options can only be set globally, not per instance\n        var unsupportedOptions = ['el', 'wrap', 'inline', 'defaultColor', 'a11y'];var _loop = function _loop(\n\n        selector) {\n          var options = instances[selector];\n\n          // If the element matches an instance's CSS selector\n          if (element.matches(selector)) {\n            currentInstanceId = selector;\n            defaultInstance = {};\n\n            // Delete unsupported options\n            unsupportedOptions.forEach(function (option) {return delete options[option];});\n\n            // Back up the default options so we can restore them later\n            for (var option in options) {\n              defaultInstance[option] = Array.isArray(settings[option]) ? settings[option].slice() : settings[option];\n            }\n\n            // Set the instance's options\n            configure(options);\n            return \"break\";\n          }};for (var selector in instances) {var _ret = _loop(selector);if (_ret === \"break\") break;\n        }\n      }\n    }\n\n    /**\r\n     * Revert any per-instance options that were previously applied.\r\n     */\n    function resetVirtualInstance() {\n      if (Object.keys(defaultInstance).length > 0) {\n        configure(defaultInstance);\n        currentInstanceId = '';\n        defaultInstance = {};\n      }\n    }\n\n    /**\r\n     * Bind the color picker to input fields that match the selector.\r\n     * @param {string} selector One or more selectors pointing to input fields.\r\n     */\n    function bindFields(selector) {\n      // Show the color picker on click on the input fields that match the selector\n      addListener(document, 'click', selector, function (event) {\n        // Skip if inline mode is in use\n        if (settings.inline) {\n          return;\n        }\n\n        // Apply any per-instance options first\n        attachVirtualInstance(event.target);\n\n        currentEl = event.target;\n        oldColor = currentEl.value;\n        currentFormat = getColorFormatFromStr(oldColor);\n        picker.classList.add('clr-open');\n\n        updatePickerPosition();\n        setColorFromStr(oldColor);\n\n        if (settings.focusInput || settings.selectInput) {\n          colorValue.focus({ preventScroll: true });\n        }\n\n        if (settings.selectInput) {\n          colorValue.select();\n        }\n\n        // Trigger an \"open\" event\n        currentEl.dispatchEvent(new Event('open', { bubbles: true }));\n      });\n\n      // Update the color preview of the input fields that match the selector\n      addListener(document, 'input', selector, function (event) {\n        var parent = event.target.parentNode;\n\n        // Only update the preview if the field has been previously wrapped\n        if (parent.classList.contains('clr-field')) {\n          parent.style.color = event.target.value;\n        }\n      });\n    }\n\n    /**\r\n     * Update the color picker's position and the color gradient's offset\r\n     */\n    function updatePickerPosition() {\n      var parent = container;\n      var scrollY = window.scrollY;\n      var pickerWidth = picker.offsetWidth;\n      var pickerHeight = picker.offsetHeight;\n      var reposition = { left: false, top: false };\n      var parentStyle, parentMarginTop, parentBorderTop;\n      var offset = { x: 0, y: 0 };\n\n      if (parent) {\n        parentStyle = window.getComputedStyle(parent);\n        parentMarginTop = parseFloat(parentStyle.marginTop);\n        parentBorderTop = parseFloat(parentStyle.borderTopWidth);\n\n        offset = parent.getBoundingClientRect();\n        offset.y += parentBorderTop + scrollY;\n      }\n\n      if (!settings.inline) {\n        var coords = currentEl.getBoundingClientRect();\n        var left = coords.x;\n        var top = scrollY + coords.y + coords.height + settings.margin;\n\n        // If the color picker is inside a custom container\n        // set the position relative to it\n        if (parent) {\n          left -= offset.x;\n          top -= offset.y;\n\n          if (left + pickerWidth > parent.clientWidth) {\n            left += coords.width - pickerWidth;\n            reposition.left = true;\n          }\n\n          if (top + pickerHeight > parent.clientHeight - parentMarginTop) {\n            if (pickerHeight + settings.margin <= coords.top - (offset.y - scrollY)) {\n              top -= coords.height + pickerHeight + settings.margin * 2;\n              reposition.top = true;\n            }\n          }\n\n          top += parent.scrollTop;\n\n          // Otherwise set the position relative to the whole document\n        } else {\n          if (left + pickerWidth > document.documentElement.clientWidth) {\n            left += coords.width - pickerWidth;\n            reposition.left = true;\n          }\n\n          if (top + pickerHeight - scrollY > document.documentElement.clientHeight) {\n            if (pickerHeight + settings.margin <= coords.top) {\n              top = scrollY + coords.y - pickerHeight - settings.margin;\n              reposition.top = true;\n            }\n          }\n        }\n\n        picker.classList.toggle('clr-left', reposition.left);\n        picker.classList.toggle('clr-top', reposition.top);\n        picker.style.left = left + \"px\";\n        picker.style.top = top + \"px\";\n      }\n\n      colorAreaDims = {\n        width: colorArea.offsetWidth,\n        height: colorArea.offsetHeight,\n        x: picker.offsetLeft + colorArea.offsetLeft + offset.x,\n        y: picker.offsetTop + colorArea.offsetTop + offset.y };\n\n    }\n\n    /**\r\n     * Wrap the linked input fields in a div that adds a color preview.\r\n     * @param {string} selector One or more selectors pointing to input fields.\r\n     */\n    function wrapFields(selector) {\n      document.querySelectorAll(selector).forEach(function (field) {\n        var parentNode = field.parentNode;\n\n        if (!parentNode.classList.contains('clr-field')) {\n          var wrapper = document.createElement('div');\n\n          wrapper.innerHTML = \"<button type=\\\"button\\\" aria-labelledby=\\\"clr-open-label\\\"></button>\";\n          parentNode.insertBefore(wrapper, field);\n          wrapper.setAttribute('class', 'clr-field');\n          wrapper.style.color = field.value;\n          wrapper.appendChild(field);\n        }\n      });\n    }\n\n    /**\r\n     * Close the color picker.\r\n     * @param {boolean} [revert] If true, revert the color to the original value.\r\n     */\n    function closePicker(revert) {\n      if (currentEl && !settings.inline) {\n        // Revert the color to the original value if needed\n        if (revert && oldColor !== currentEl.value) {\n          currentEl.value = oldColor;\n\n          // Trigger an \"input\" event to force update the thumbnail next to the input field\n          currentEl.dispatchEvent(new Event('input', { bubbles: true }));\n        }\n\n        if (oldColor !== currentEl.value) {\n          currentEl.dispatchEvent(new Event('change', { bubbles: true }));\n        }\n\n        // Hide the picker dialog\n        picker.classList.remove('clr-open');\n\n        // Reset any previously set per-instance options\n        if (hasInstance) {\n          resetVirtualInstance();\n        }\n\n        // Trigger a \"close\" event\n        currentEl.dispatchEvent(new Event('close', { bubbles: true }));\n\n        if (settings.focusInput) {\n          currentEl.focus({ preventScroll: true });\n        }\n\n        currentEl = null;\n      }\n    }\n\n    /**\r\n     * Set the active color from a string.\r\n     * @param {string} str String representing a color.\r\n     */\n    function setColorFromStr(str) {\n      var rgba = strToRGBA(str);\n      var hsva = RGBAtoHSVA(rgba);\n\n      updateMarkerA11yLabel(hsva.s, hsva.v);\n      updateColor(rgba, hsva);\n\n      // Update the UI\n      hueSlider.value = hsva.h;\n      picker.style.color = \"hsl(\" + hsva.h + \", 100%, 50%)\";\n      hueMarker.style.left = hsva.h / 360 * 100 + \"%\";\n\n      colorMarker.style.left = colorAreaDims.width * hsva.s / 100 + \"px\";\n      colorMarker.style.top = colorAreaDims.height - colorAreaDims.height * hsva.v / 100 + \"px\";\n\n      alphaSlider.value = hsva.a * 100;\n      alphaMarker.style.left = hsva.a * 100 + \"%\";\n    }\n\n    /**\r\n     * Guess the color format from a string.\r\n     * @param {string} str String representing a color.\r\n     * @return {string} The color format.\r\n     */\n    function getColorFormatFromStr(str) {\n      var format = str.substring(0, 3).toLowerCase();\n\n      if (format === 'rgb' || format === 'hsl') {\n        return format;\n      }\n\n      return 'hex';\n    }\n\n    /**\r\n     * Copy the active color to the linked input field.\r\n     * @param {number} [color] Color value to override the active color.\r\n     */\n    function pickColor(color) {\n      color = color !== undefined ? color : colorValue.value;\n\n      if (currentEl) {\n        currentEl.value = color;\n        currentEl.dispatchEvent(new Event('input', { bubbles: true }));\n      }\n\n      document.dispatchEvent(new CustomEvent('coloris:pick', { detail: { color: color } }));\n    }\n\n    /**\r\n     * Set the active color based on a specific point in the color gradient.\r\n     * @param {number} x Left position.\r\n     * @param {number} y Top position.\r\n     */\n    function setColorAtPosition(x, y) {\n      var hsva = {\n        h: hueSlider.value * 1,\n        s: x / colorAreaDims.width * 100,\n        v: 100 - y / colorAreaDims.height * 100,\n        a: alphaSlider.value / 100 };\n\n      var rgba = HSVAtoRGBA(hsva);\n\n      updateMarkerA11yLabel(hsva.s, hsva.v);\n      updateColor(rgba, hsva);\n      pickColor();\n    }\n\n    /**\r\n     * Update the color marker's accessibility label.\r\n     * @param {number} saturation\r\n     * @param {number} value\r\n     */\n    function updateMarkerA11yLabel(saturation, value) {\n      var label = settings.a11y.marker;\n\n      saturation = saturation.toFixed(1) * 1;\n      value = value.toFixed(1) * 1;\n      label = label.replace('{s}', saturation);\n      label = label.replace('{v}', value);\n      colorMarker.setAttribute('aria-label', label);\n    }\n\n    //\n    /**\r\n     * Get the pageX and pageY positions of the pointer.\r\n     * @param {object} event The MouseEvent or TouchEvent object.\r\n     * @return {object} The pageX and pageY positions.\r\n     */\n    function getPointerPosition(event) {\n      return {\n        pageX: event.changedTouches ? event.changedTouches[0].pageX : event.pageX,\n        pageY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY };\n\n    }\n\n    /**\r\n     * Move the color marker when dragged.\r\n     * @param {object} event The MouseEvent object.\r\n     */\n    function moveMarker(event) {\n      var pointer = getPointerPosition(event);\n      var x = pointer.pageX - colorAreaDims.x;\n      var y = pointer.pageY - colorAreaDims.y;\n\n      if (container) {\n        y += container.scrollTop;\n      }\n\n      x = x < 0 ? 0 : x > colorAreaDims.width ? colorAreaDims.width : x;\n      y = y < 0 ? 0 : y > colorAreaDims.height ? colorAreaDims.height : y;\n\n      colorMarker.style.left = x + \"px\";\n      colorMarker.style.top = y + \"px\";\n\n      setColorAtPosition(x, y);\n\n      // Prevent scrolling while dragging the marker\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    /**\r\n     * Move the color marker when the arrow keys are pressed.\r\n     * @param {number} offsetX The horizontal amount to move.\r\n     * * @param {number} offsetY The vertical amount to move.\r\n     */\n    function moveMarkerOnKeydown(offsetX, offsetY) {\n      var x = colorMarker.style.left.replace('px', '') * 1 + offsetX;\n      var y = colorMarker.style.top.replace('px', '') * 1 + offsetY;\n\n      colorMarker.style.left = x + \"px\";\n      colorMarker.style.top = y + \"px\";\n\n      setColorAtPosition(x, y);\n    }\n\n    /**\r\n     * Update the color picker's input field and preview thumb.\r\n     * @param {Object} rgba Red, green, blue and alpha values.\r\n     * @param {Object} [hsva] Hue, saturation, value and alpha values.\r\n     */\n    function updateColor(rgba, hsva) {if (rgba === void 0) {rgba = {};}if (hsva === void 0) {hsva = {};}\n      var format = settings.format;\n\n      for (var key in rgba) {\n        currentColor[key] = rgba[key];\n      }\n\n      for (var _key in hsva) {\n        currentColor[_key] = hsva[_key];\n      }\n\n      var hex = RGBAToHex(currentColor);\n      var opaqueHex = hex.substring(0, 7);\n\n      colorMarker.style.color = opaqueHex;\n      alphaMarker.parentNode.style.color = opaqueHex;\n      alphaMarker.style.color = hex;\n      colorPreview.style.color = hex;\n\n      // Force repaint the color and alpha gradients as a workaround for a Google Chrome bug\n      colorArea.style.display = 'none';\n      colorArea.offsetHeight;\n      colorArea.style.display = '';\n      alphaMarker.nextElementSibling.style.display = 'none';\n      alphaMarker.nextElementSibling.offsetHeight;\n      alphaMarker.nextElementSibling.style.display = '';\n\n      if (format === 'mixed') {\n        format = currentColor.a === 1 ? 'hex' : 'rgb';\n      } else if (format === 'auto') {\n        format = currentFormat;\n      }\n\n      switch (format) {\n        case 'hex':\n          colorValue.value = hex;\n          break;\n        case 'rgb':\n          colorValue.value = RGBAToStr(currentColor);\n          break;\n        case 'hsl':\n          colorValue.value = HSLAToStr(HSVAtoHSLA(currentColor));\n          break;}\n\n\n      // Select the current format in the format switcher\n      document.querySelector(\".clr-format [value=\\\"\" + format + \"\\\"]\").checked = true;\n    }\n\n    /**\r\n     * Set the hue when its slider is moved.\r\n     */\n    function setHue() {\n      var hue = hueSlider.value * 1;\n      var x = colorMarker.style.left.replace('px', '') * 1;\n      var y = colorMarker.style.top.replace('px', '') * 1;\n\n      picker.style.color = \"hsl(\" + hue + \", 100%, 50%)\";\n      hueMarker.style.left = hue / 360 * 100 + \"%\";\n\n      setColorAtPosition(x, y);\n    }\n\n    /**\r\n     * Set the alpha when its slider is moved.\r\n     */\n    function setAlpha() {\n      var alpha = alphaSlider.value / 100;\n\n      alphaMarker.style.left = alpha * 100 + \"%\";\n      updateColor({ a: alpha });\n      pickColor();\n    }\n\n    /**\r\n     * Convert HSVA to RGBA.\r\n     * @param {object} hsva Hue, saturation, value and alpha values.\r\n     * @return {object} Red, green, blue and alpha values.\r\n     */\n    function HSVAtoRGBA(hsva) {\n      var saturation = hsva.s / 100;\n      var value = hsva.v / 100;\n      var chroma = saturation * value;\n      var hueBy60 = hsva.h / 60;\n      var x = chroma * (1 - Math.abs(hueBy60 % 2 - 1));\n      var m = value - chroma;\n\n      chroma = chroma + m;\n      x = x + m;\n\n      var index = Math.floor(hueBy60) % 6;\n      var red = [chroma, x, m, m, x, chroma][index];\n      var green = [x, chroma, chroma, x, m, m][index];\n      var blue = [m, m, x, chroma, chroma, x][index];\n\n      return {\n        r: Math.round(red * 255),\n        g: Math.round(green * 255),\n        b: Math.round(blue * 255),\n        a: hsva.a };\n\n    }\n\n    /**\r\n     * Convert HSVA to HSLA.\r\n     * @param {object} hsva Hue, saturation, value and alpha values.\r\n     * @return {object} Hue, saturation, lightness and alpha values.\r\n     */\n    function HSVAtoHSLA(hsva) {\n      var value = hsva.v / 100;\n      var lightness = value * (1 - hsva.s / 100 / 2);\n      var saturation;\n\n      if (lightness > 0 && lightness < 1) {\n        saturation = Math.round((value - lightness) / Math.min(lightness, 1 - lightness) * 100);\n      }\n\n      return {\n        h: hsva.h,\n        s: saturation || 0,\n        l: Math.round(lightness * 100),\n        a: hsva.a };\n\n    }\n\n    /**\r\n     * Convert RGBA to HSVA.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {object} Hue, saturation, value and alpha values.\r\n     */\n    function RGBAtoHSVA(rgba) {\n      var red = rgba.r / 255;\n      var green = rgba.g / 255;\n      var blue = rgba.b / 255;\n      var xmax = Math.max(red, green, blue);\n      var xmin = Math.min(red, green, blue);\n      var chroma = xmax - xmin;\n      var value = xmax;\n      var hue = 0;\n      var saturation = 0;\n\n      if (chroma) {\n        if (xmax === red) {hue = (green - blue) / chroma;}\n        if (xmax === green) {hue = 2 + (blue - red) / chroma;}\n        if (xmax === blue) {hue = 4 + (red - green) / chroma;}\n        if (xmax) {saturation = chroma / xmax;}\n      }\n\n      hue = Math.floor(hue * 60);\n\n      return {\n        h: hue < 0 ? hue + 360 : hue,\n        s: Math.round(saturation * 100),\n        v: Math.round(value * 100),\n        a: rgba.a };\n\n    }\n\n    /**\r\n     * Parse a string to RGBA.\r\n     * @param {string} str String representing a color.\r\n     * @return {object} Red, green, blue and alpha values.\r\n     */\n    function strToRGBA(str) {\n      var regex = /^((rgba)|rgb)[\\D]+([\\d.]+)[\\D]+([\\d.]+)[\\D]+([\\d.]+)[\\D]*?([\\d.]+|$)/i;\n      var match, rgba;\n\n      // Default to black for invalid color strings\n      ctx.fillStyle = '#000';\n\n      // Use canvas to convert the string to a valid color string\n      ctx.fillStyle = str;\n      match = regex.exec(ctx.fillStyle);\n\n      if (match) {\n        rgba = {\n          r: match[3] * 1,\n          g: match[4] * 1,\n          b: match[5] * 1,\n          a: match[6] * 1 };\n\n\n        // Workaround to mitigate a Chromium bug where the alpha value is rounded incorrectly\n        rgba.a = +rgba.a.toFixed(2);\n\n      } else {\n        match = ctx.fillStyle.replace('#', '').match(/.{2}/g).map(function (h) {return parseInt(h, 16);});\n        rgba = {\n          r: match[0],\n          g: match[1],\n          b: match[2],\n          a: 1 };\n\n      }\n\n      return rgba;\n    }\n\n    /**\r\n     * Convert RGBA to Hex.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {string} Hex color string.\r\n     */\n    function RGBAToHex(rgba) {\n      var R = rgba.r.toString(16);\n      var G = rgba.g.toString(16);\n      var B = rgba.b.toString(16);\n      var A = '';\n\n      if (rgba.r < 16) {\n        R = '0' + R;\n      }\n\n      if (rgba.g < 16) {\n        G = '0' + G;\n      }\n\n      if (rgba.b < 16) {\n        B = '0' + B;\n      }\n\n      if (settings.alpha && (rgba.a < 1 || settings.forceAlpha)) {\n        var alpha = rgba.a * 255 | 0;\n        A = alpha.toString(16);\n\n        if (alpha < 16) {\n          A = '0' + A;\n        }\n      }\n\n      return '#' + R + G + B + A;\n    }\n\n    /**\r\n     * Convert RGBA values to a CSS rgb/rgba string.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {string} CSS color string.\r\n     */\n    function RGBAToStr(rgba) {\n      if (!settings.alpha || rgba.a === 1 && !settings.forceAlpha) {\n        return \"rgb(\" + rgba.r + \", \" + rgba.g + \", \" + rgba.b + \")\";\n      } else {\n        return \"rgba(\" + rgba.r + \", \" + rgba.g + \", \" + rgba.b + \", \" + rgba.a + \")\";\n      }\n    }\n\n    /**\r\n     * Convert HSLA values to a CSS hsl/hsla string.\r\n     * @param {object} hsla Hue, saturation, lightness and alpha values.\r\n     * @return {string} CSS color string.\r\n     */\n    function HSLAToStr(hsla) {\n      if (!settings.alpha || hsla.a === 1 && !settings.forceAlpha) {\n        return \"hsl(\" + hsla.h + \", \" + hsla.s + \"%, \" + hsla.l + \"%)\";\n      } else {\n        return \"hsla(\" + hsla.h + \", \" + hsla.s + \"%, \" + hsla.l + \"%, \" + hsla.a + \")\";\n      }\n    }\n\n    /**\r\n     * Init the color picker.\r\n     */\n    function init() {\n      // Render the UI\n      container = null;\n      picker = document.createElement('div');\n      picker.setAttribute('id', 'clr-picker');\n      picker.className = 'clr-picker';\n      picker.innerHTML =\n      \"<input id=\\\"clr-color-value\\\" class=\\\"clr-color\\\" type=\\\"text\\\" value=\\\"\\\" spellcheck=\\\"false\\\" aria-label=\\\"\" + settings.a11y.input + \"\\\">\" + (\"<div id=\\\"clr-color-area\\\" class=\\\"clr-gradient\\\" role=\\\"application\\\" aria-label=\\\"\" +\n      settings.a11y.instruction + \"\\\">\") +\n      '<div id=\"clr-color-marker\" class=\"clr-marker\" tabindex=\"0\"></div>' +\n      '</div>' +\n      '<div class=\"clr-hue\">' + (\"<input id=\\\"clr-hue-slider\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"360\\\" step=\\\"1\\\" aria-label=\\\"\" +\n      settings.a11y.hueSlider + \"\\\">\") +\n      '<div id=\"clr-hue-marker\"></div>' +\n      '</div>' +\n      '<div class=\"clr-alpha\">' + (\"<input id=\\\"clr-alpha-slider\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"100\\\" step=\\\"1\\\" aria-label=\\\"\" +\n      settings.a11y.alphaSlider + \"\\\">\") +\n      '<div id=\"clr-alpha-marker\"></div>' +\n      '<span></span>' +\n      '</div>' +\n      '<div id=\"clr-format\" class=\"clr-format\">' +\n      '<fieldset class=\"clr-segmented\">' + (\"<legend>\" +\n      settings.a11y.format + \"</legend>\") +\n      '<input id=\"clr-f1\" type=\"radio\" name=\"clr-format\" value=\"hex\">' +\n      '<label for=\"clr-f1\">Hex</label>' +\n      '<input id=\"clr-f2\" type=\"radio\" name=\"clr-format\" value=\"rgb\">' +\n      '<label for=\"clr-f2\">RGB</label>' +\n      '<input id=\"clr-f3\" type=\"radio\" name=\"clr-format\" value=\"hsl\">' +\n      '<label for=\"clr-f3\">HSL</label>' +\n      '<span></span>' +\n      '</fieldset>' +\n      '</div>' +\n      '<div id=\"clr-swatches\" class=\"clr-swatches\"></div>' + (\"<button type=\\\"button\\\" id=\\\"clr-clear\\\" class=\\\"clr-clear\\\">\" +\n      settings.clearLabel + \"</button>\") + (\"<button type=\\\"button\\\" id=\\\"clr-color-preview\\\" class=\\\"clr-preview\\\" aria-label=\\\"\" +\n      settings.a11y.close + \"\\\"></button>\") + (\"<span id=\\\"clr-open-label\\\" hidden>\" +\n      settings.a11y.open + \"</span>\") + (\"<span id=\\\"clr-swatch-label\\\" hidden>\" +\n      settings.a11y.swatch + \"</span>\");\n\n      // Append the color picker to the DOM\n      document.body.appendChild(picker);\n\n      // Reference the UI elements\n      colorArea = getEl('clr-color-area');\n      colorMarker = getEl('clr-color-marker');\n      clearButton = getEl('clr-clear');\n      colorPreview = getEl('clr-color-preview');\n      colorValue = getEl('clr-color-value');\n      hueSlider = getEl('clr-hue-slider');\n      hueMarker = getEl('clr-hue-marker');\n      alphaSlider = getEl('clr-alpha-slider');\n      alphaMarker = getEl('clr-alpha-marker');\n\n      // Bind the picker to the default selector\n      bindFields(settings.el);\n      wrapFields(settings.el);\n\n      addListener(picker, 'mousedown', function (event) {\n        picker.classList.remove('clr-keyboard-nav');\n        event.stopPropagation();\n      });\n\n      addListener(colorArea, 'mousedown', function (event) {\n        addListener(document, 'mousemove', moveMarker);\n      });\n\n      addListener(colorArea, 'touchstart', function (event) {\n        document.addEventListener('touchmove', moveMarker, { passive: false });\n      });\n\n      addListener(colorMarker, 'mousedown', function (event) {\n        addListener(document, 'mousemove', moveMarker);\n      });\n\n      addListener(colorMarker, 'touchstart', function (event) {\n        document.addEventListener('touchmove', moveMarker, { passive: false });\n      });\n\n      addListener(colorValue, 'change', function (event) {\n        setColorFromStr(colorValue.value);\n        pickColor();\n      });\n\n      addListener(clearButton, 'click', function (event) {\n        pickColor('');\n        closePicker();\n      });\n\n      addListener(colorPreview, 'click', function (event) {\n        pickColor();\n        closePicker();\n      });\n\n      addListener(document, 'click', '.clr-format input', function (event) {\n        currentFormat = event.target.value;\n        updateColor();\n        pickColor();\n      });\n\n      addListener(picker, 'click', '.clr-swatches button', function (event) {\n        setColorFromStr(event.target.textContent);\n        pickColor();\n\n        if (settings.swatchesOnly) {\n          closePicker();\n        }\n      });\n\n      addListener(document, 'mouseup', function (event) {\n        document.removeEventListener('mousemove', moveMarker);\n      });\n\n      addListener(document, 'touchend', function (event) {\n        document.removeEventListener('touchmove', moveMarker);\n      });\n\n      addListener(document, 'mousedown', function (event) {\n        picker.classList.remove('clr-keyboard-nav');\n        closePicker();\n      });\n\n      addListener(document, 'keydown', function (event) {\n        if (event.key === 'Escape') {\n          closePicker(true);\n        } else if (event.key === 'Tab') {\n          picker.classList.add('clr-keyboard-nav');\n        }\n      });\n\n      addListener(document, 'click', '.clr-field button', function (event) {\n        // Reset any previously set per-instance options\n        if (hasInstance) {\n          resetVirtualInstance();\n        }\n\n        // Open the color picker\n        event.target.nextElementSibling.dispatchEvent(new Event('click', { bubbles: true }));\n      });\n\n      addListener(colorMarker, 'keydown', function (event) {\n        var movements = {\n          ArrowUp: [0, -1],\n          ArrowDown: [0, 1],\n          ArrowLeft: [-1, 0],\n          ArrowRight: [1, 0] };\n\n\n        if (Object.keys(movements).indexOf(event.key) !== -1) {\n          moveMarkerOnKeydown.apply(void 0, movements[event.key]);\n          event.preventDefault();\n        }\n      });\n\n      addListener(colorArea, 'click', moveMarker);\n      addListener(hueSlider, 'input', setHue);\n      addListener(alphaSlider, 'input', setAlpha);\n    }\n\n    /**\r\n     * Shortcut for getElementById to optimize the minified JS.\r\n     * @param {string} id The element id.\r\n     * @return {object} The DOM element with the provided id.\r\n     */\n    function getEl(id) {\n      return document.getElementById(id);\n    }\n\n    /**\r\n     * Shortcut for addEventListener to optimize the minified JS.\r\n     * @param {object} context The context to which the listener is attached.\r\n     * @param {string} type Event type.\r\n     * @param {(string|function)} selector Event target if delegation is used, event handler if not.\r\n     * @param {function} [fn] Event handler if delegation is used.\r\n     */\n    function addListener(context, type, selector, fn) {\n      var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n      // Delegate event to the target of the selector\n      if (typeof selector === 'string') {\n        context.addEventListener(type, function (event) {\n          if (matches.call(event.target, selector)) {\n            fn.call(event.target, event);\n          }\n        });\n\n        // If the selector is not a string then it's a function\n        // in which case we need regular event listener\n      } else {\n        fn = selector;\n        context.addEventListener(type, fn);\n      }\n    }\n\n    /**\r\n     * Call a function only when the DOM is ready.\r\n     * @param {function} fn The function to call.\r\n     * @param {array} [args] Arguments to pass to the function.\r\n     */\n    function DOMReady(fn, args) {\n      args = args !== undefined ? args : [];\n\n      if (document.readyState !== 'loading') {\n        fn.apply(void 0, args);\n      } else {\n        document.addEventListener('DOMContentLoaded', function () {\n          fn.apply(void 0, args);\n        });\n      }\n    }\n\n    // Polyfill for Nodelist.forEach\n    if (NodeList !== undefined && NodeList.prototype && !NodeList.prototype.forEach) {\n      NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n\n    // Expose the color picker to the global scope\n    var Coloris = function () {\n      var methods = {\n        init: init,\n        set: configure,\n        wrap: wrapFields,\n        close: closePicker,\n        setInstance: setVirtualInstance,\n        removeInstance: removeVirtualInstance,\n        updatePosition: updatePickerPosition };\n\n\n      function Coloris(options) {\n        DOMReady(function () {\n          if (options) {\n            if (typeof options === 'string') {\n              bindFields(options);\n            } else {\n              configure(options);\n            }\n          }\n        });\n      }var _loop2 = function _loop2(\n\n      key) {\n        Coloris[key] = function () {for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {args[_key2] = arguments[_key2];}\n          DOMReady(methods[key], args);\n        };};for (var key in methods) {_loop2(key);\n      }\n\n      return Coloris;\n    }();\n\n    // Ensure init function is available not only as as a default import\n    Coloris.coloris = Coloris;\n\n    // Init the color picker when the DOM is ready\n    return Coloris;\n\n  }(window, document, Math);\n\n}();\n\nvar _coloris = Coloris.coloris;\nvar _init = Coloris.init;\nvar _set = Coloris.set;\nvar _wrap = Coloris.wrap;\nvar _close = Coloris.close;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Coloris);\n\n\n//# sourceURL=webpack://jsdraw/../../node_modules/@melloware/coloris/dist/esm/coloris.js?");

/***/ }),

/***/ "../../node_modules/bezier-js/src/bezier.js":
/*!**************************************************!*\
  !*** ../../node_modules/bezier-js/src/bezier.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bezier\": () => (/* binding */ Bezier)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../node_modules/bezier-js/src/utils.js\");\n/* harmony import */ var _poly_bezier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./poly-bezier.js */ \"../../node_modules/bezier-js/src/poly-bezier.js\");\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\n\n\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return _poly_bezier_js__WEBPACK_IMPORTED_MODULE_1__.PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(_utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeline(bline[2], fline[0]);\n      const le = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new _poly_bezier_js__WEBPACK_IMPORTED_MODULE_1__.PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeline(bs, fs),\n      le = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new _poly_bezier_js__WEBPACK_IMPORTED_MODULE_1__.PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.between(p.x, mx, MX) && _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(pc, np1),\n      d1 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(pc, c1),\n      d2 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\n\n\n\n//# sourceURL=webpack://jsdraw/../../node_modules/bezier-js/src/bezier.js?");

/***/ }),

/***/ "../../node_modules/bezier-js/src/poly-bezier.js":
/*!*******************************************************!*\
  !*** ../../node_modules/bezier-js/src/poly-bezier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PolyBezier\": () => (/* binding */ PolyBezier)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../node_modules/bezier-js/src/utils.js\");\n\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      _utils_js__WEBPACK_IMPORTED_MODULE_0__.utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\n\n\n\n//# sourceURL=webpack://jsdraw/../../node_modules/bezier-js/src/poly-bezier.js?");

/***/ }),

/***/ "../../node_modules/bezier-js/src/utils.js":
/*!*************************************************!*\
  !*** ../../node_modules/bezier-js/src/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"utils\": () => (/* binding */ utils)\n/* harmony export */ });\n/* harmony import */ var _bezier_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier.js */ \"../../node_modules/bezier-js/src/bezier.js\");\n\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new _bezier_js__WEBPACK_IMPORTED_MODULE_0__.Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x' + y')^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z') + (z'x\" - z\"x') + (x'y\" - x\"y'))\n    //   k(t) = -------------------------------------------------------\n    //                     (x' + y' + z')^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\n\n\n\n//# sourceURL=webpack://jsdraw/../../node_modules/bezier-js/src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./example.ts");
/******/ 	window.jsdraw = __webpack_exports__;
/******/ 	
/******/ })()
;